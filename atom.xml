<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Shining IO]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://yoursite.com/"/>
  <updated>2014-04-01T14:47:33.250Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name><![CDATA[Shining Chan]]></name>
    
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[从一个Clear式TableView的实现看iOS手势识别机制]]></title>
    <link href="http://yoursite.com/2014/03/29/see-ios-gesture-recognition-with-a-copy-of-clear/"/>
    <id>http://yoursite.com/2014/03/29/see-ios-gesture-recognition-with-a-copy-of-clear/</id>
    <published>2014-03-29T11:33:02.000Z</published>
    <updated>2014-03-29T11:37:11.000Z</updated>
    <content type="html"><![CDATA[<h2 id="-">前言</h2>
<p>TableView大概是iOS开发者在写UI代码时最常使用到的控件，而手势识别亦是iOS平台下最引以为豪的功能点之一，这两者结合一下会发生什么？我首先想到是<a href="http://itunes.apple.com/us/app/clear/id493136154?mt=8" target="_blank">Clear</a>，这个两年前曾一度火热的效率类应用，算是在iOS平台下将手势和TableView玩到了极致的典范。虽然Clear本身并不开源，我们看不到它的源代码，不过在Github搜索了一番，倒是发现了一个模仿得不错的<a href="https://github.com/jamztang/JTGestureBasedTableViewDemo" target="_blank">Demo</a>。于是就借这个demo来学习和整理下iOS下的手势识别机制。</p>
<a id="more"></a>

<h2 id="-uiresponder-">从UIResponder谈起</h2>
<p>细心的开发者会发现，iOS下所有UI相关的对象，包括UIView,UIWindow,UIApplication都是UIResponder的子类，其实从字面意思也可以看出，这个类是用来处理用户的触摸事件的。</p>
<p>该类有以下几个常用的方法：</p>
<ul>
<li>touchesBegan:withEvent:</li>
<li>touchesMoved:withEvent:</li>
<li>touchesEnded:withEvent:</li>
<li>touchesCancelled:withEvent:</li>
</ul>
<p>以上这些方法提供给开发者重写，用来对用户的触摸事件做反馈。既然这个类能处理触摸事件，那只要对触摸轨迹进行捕捉判断，就基本能够确认用户的手势了。早期的开发者也的确就是这样做的，不过这种方式来判断手势还是比较麻烦的，于是苹果在iOS 3.2之后引入了UIGestureRecognizer，用来简化触摸手势的识别。</p>
<h2 id="uigesturerecognizer">UIGestureRecognizer</h2>
<p>UIGestureRecognizer是NSObject的子类，该类本身是一个抽象类，因此不能直接拿来用，一般使用到的是以下子类：</p>
<table>
<thead>
<tr>
<th>Class</th>
<th>对应手势</th>
</tr>
</thead>
<tbody>
<tr>
<td>UITapGestureRecognizer</td>
<td>单击</td>
</tr>
<tr>
<td>UIPinchGestureRecognizer</td>
<td>双指放大缩小</td>
</tr>
<tr>
<td>UIRotationGestureRecognizer</td>
<td>旋转</td>
</tr>
<tr>
<td>UISwipeGestureRecognizer</td>
<td>滑动</td>
</tr>
<tr>
<td>UIPanGestureRecognizer</td>
<td>拖动</td>
</tr>
<tr>
<td>UIScreenEdgePanGestureRecognizer</td>
<td>滑动返回（iOS7之后引入）</td>
</tr>
<tr>
<td>UILongPressGestureRecognizer</td>
<td>长按</td>
</tr>
</tbody>
</table>
<h2 id="clear-">Clear使用到的手势</h2>
<p>就Clear这个应用而言，使用到了以下这些手势来执行操作：</p>
<table>
<thead>
<tr>
<th>手势</th>
<th>操作</th>
</tr>
</thead>
<tbody>
<tr>
<td>Pan</td>
<td>向下拖动创建一个新任务</td>
</tr>
<tr>
<td>Tap</td>
<td>点击Cell进行输入操作</td>
</tr>
<tr>
<td>Swipe</td>
<td>右滑完成任务/左滑删除任务</td>
</tr>
<tr>
<td>Pinch</td>
<td>在两个Cell之间放大创建新任务</td>
</tr>
<tr>
<td>LongPress</td>
<td>长按进行任务的重排</td>
</tr>
</tbody>
</table>
<h2 id="demo-">Demo的实现</h2>
<p>直接查看demo的源码，作者自己实现了一个TableViewGestureRecognizer，封装了以上的一些操作。</p>
<p>首先用enum定义了Recognizer的5个状态：</p>
<ul>
<li>JTTableViewGestureRecognizerStateNone      </li>
<li>JTTableViewGestureRecognizerStateDragging  </li>
<li>JTTableViewGestureRecognizerStatePinching  </li>
<li>JTTableViewGestureRecognizerStatePanning</li>
<li>JTTableViewGestureRecognizerStateMoving   </li>
</ul>
<p>由于要对手势进行识别，实现了<code>UIGestureRecognizerDelegate</code>这个protocol。</p>
<p>作者重写了protocol中的<code>gestureRecognizerShouldBegin</code>方法，这个方法会在手势识别开始前调用。在这里对不同手势进行了甄别，然后分别执行不同的delegate方法。</p>
<p>Recognizer中定义了3个delegate方法，分别是：</p>
<ul>
<li>JTTableViewGestureAddingRowDelegate</li>
<li>JTTableViewGestureEditingRowDelegate</li>
<li>JTTableViewGestureMoveRowDelegate</li>
</ul>
<p>以上3个方法对应了每个cell的添加，编辑以及移动操作，这些delegate提供给调用方的tableview，用来处理捕捉到手势后的回调。</p>
<p>以长按事件为例，在识别到该手势时，进行了如下操作：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre><span class="keyword">...</span>
<span class="keyword">else</span> <span class="keyword">if</span> (gestureRecognizer == self.longPressRecognizer) {
        
        CGPoint location = [gestureRecognizer locationInView:self.tableView];
        NSIndexPath *indexPath = [self.tableView indexPathForRowAtPoint:location];

        <span class="keyword">if</span> (indexPath && [self.delegate conformsToProtocol:@protocol(JTTableViewGestureMoveRowDelegate)]) {
            BOOL canMoveRow = [self.delegate gestureRecognizer:self canMoveRowAtIndexPath:indexPath];
            <span class="keyword">return</span> canMoveRow;
        }
        <span class="keyword">return</span> NO;
    }
<span class="keyword">...</span>
</pre></td></tr></table></figure>

<p>以上这段代码先是确定了当前触发事件的cell索引数，然后执行JTTableViewGestureMoveRowDelegate中的<code>canMoveRowAtIndexPath:indexPath</code>方法，根据返回的布尔值来判断是否需要移动。</p>
<p>其他两种操作也是基本遵守了同样的调用路径，就不赘述了，有兴趣的可以直接查看原作者的<a href="https://github.com/jamztang/JTGestureBasedTableViewDemo" target="_blank">源码</a>。</p>
]]></content>
    <summary type="html"><![CDATA[<h2 id="-">前言</h2>
<p>TableView大概是iOS开发者在写UI代码时最常使用到的控件，而手势识别亦是iOS平台下最引以为豪的功能点之一，这两者结合一下会发生什么？我首先想到是<a href="http://itunes.apple.com/us/app/clear/id493136154?mt=8" target="_blank">Clear</a>，这个两年前曾一度火热的效率类应用，算是在iOS平台下将手势和TableView玩到了极致的典范。虽然Clear本身并不开源，我们看不到它的源代码，不过在Github搜索了一番，倒是发现了一个模仿得不错的<a href="https://github.com/jamztang/JTGestureBasedTableViewDemo" target="_blank">Demo</a>。于是就借这个demo来学习和整理下iOS下的手势识别机制。</p>
]]></summary>
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用PonyDebugger调试iOS应用]]></title>
    <link href="http://yoursite.com/2014/03/20/debug-ios-app-with-pony-debugger/"/>
    <id>http://yoursite.com/2014/03/20/debug-ios-app-with-pony-debugger/</id>
    <published>2014-03-20T15:35:59.000Z</published>
    <updated>2014-03-20T15:35:59.000Z</updated>
    <content type="html"><![CDATA[<h2 id="-">前言</h2>
<p>Debug算是开发者的基本技能之一吧，对于iOS开发者而言，可能会遇到如下一些debug需求：</p>
<ul>
<li>调试网络请求问题</li>
<li>调试一个层次结构复杂的用户界面</li>
<li>查看应用内Core Data数据变化</li>
</ul>
<p>虽然你可以通过NSLog日志，打断点，抑或LLDB的调试命令等一些常见手段来解决以上问题，但这些方式始终不够直观，效率也不高，特别是对于调试UI这个需求。要提高效率，我们可以使用一些第三方的调试工具，比如本文要介绍的PonyDebugger。</p>
<a id="more"></a>

<h2 id="-ponydebugger">关于PonyDebugger</h2>
<p><a href="https://github.com/square/PonyDebugger" target="_blank">PonyDebugger</a>是Square开源的一个远程调试工具包，它可以通过Chrome开发者工具来调试iOS应用的网络流量，数据存储以及用户界面。</p>
<h2 id="-">安装和使用</h2>
<h3 id="-">服务端安装</h3>
<p><code>curl -sk https://cloud.github.com/downloads/square/PonyDebugger/bootstrap-ponyd.py | \
  python - --ponyd-symlink=/usr/local/bin/ponyd ~/Library/PonyDebugger</code></p>
<p>安装时遇到的一些坑记录如下：</p>
<ol>
<li><p>移动宽带下偶尔出现连接不上pypi的情况，使用电信宽带则正常，移动宽带用户可以改用国内的镜像地址，比如V2EX的pypi镜像 <a href="http://pypi.v2ex.com/simple" target="_blank">http://pypi.v2ex.com/simple</a></p>
</li>
<li><p>服务端依赖pybonjour，但是在zsh终端下使用pip安装会提示找不到这个包，需要手动安装，添加allow-external和allow-unverified</p>
</li>
</ol>
<p>手动安装方法如下：</p>
<p><code>source ~/Library/PonyDebugger/bin/activate</code></p>
<p><code>pip install -U -e git+https://github.com/square/PonyDebugger.git#egg=ponydebugger --allow-external pybonjour --allow-unverified pybonjour</code></p>
<p><code>ponyd update-devtools</code></p>
<h3 id="-">客户端安装</h3>
<p>使用CocoaPods，在PodFile中添加以下依赖：</p>
<p><code>pod &#39;PonyDebugger&#39;, &#39;~&gt; 0.3.1&#39;</code></p>
<p>也可以直接指向Github开源地址，这样可以随时使用最新版本的代码：</p>
<p><code>pod &#39;PonyDebugger&#39;, :git =&gt; &#39;https://github.com/square/PonyDebugger.git&#39;</code></p>
<h3 id="-">使用</h3>
<p>终端输入以下命令启动服务端，然后Chrome打开<a href="http://localhost:9000" target="_blank">http://localhost:9000</a> ，使用开发者工具即可进行调试</p>
<p><code>ponyd serve --listen-interface=127.0.0.1</code></p>
<p>为了便于随时开启和关闭PonyDebugger，客户端在Preprocessor Macros中定义了一个宏ENABLE_PONYDEBUGGER</p>
<p>在AppDeleagate的didFinishLaunchingWithOptions方法中使用如下代码进行一些初始化工作：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre></td><td class="code"><pre><span class="comment">#if ENABLE_PONYDEBUGGER</span>

    PDDebugger *<span class="keyword">debugger</span> = [PDDebugger defaultInstance];
    
    <span class="regexp">//</span> Enable Network debugging, <span class="keyword">and</span> automatically track network traffic that comes through any classes that NSURLConnectionDelegate methods.
    [<span class="keyword">debugger</span> enableNetworkTrafficDebugging];
    [<span class="keyword">debugger</span> forwardAllNetworkTraffic];
    
    <span class="regexp">//</span> Enable Core Data debugging, <span class="keyword">and</span> broadcast the main managed object context.
    [<span class="keyword">debugger</span> enableCoreDataDebugging];
    [<span class="keyword">debugger</span> <span class="attribute">addManagedObjectContext</span>:self.managedObjectContext <span class="attribute">withName</span>:@<span class="string">"Twitter Test MOC"</span>];
    
    <span class="regexp">//</span> Enable View Hierarchy debugging. This will swizzle UIView methods to monitor changes <span class="keyword">in</span> the hierarchy
    <span class="regexp">//</span> Choose a few UIView key paths to display as attributes <span class="keyword">of</span> the dom nodes
    [<span class="keyword">debugger</span> enableViewHierarchyDebugging];
    [<span class="keyword">debugger</span> <span class="attribute">setDisplayedViewAttributeKeyPaths</span>:@[@<span class="string">"frame"</span>, @<span class="string">"hidden"</span>, @<span class="string">"alpha"</span>, @<span class="string">"opaque"</span>, @<span class="string">"accessibilityLabel"</span>, @<span class="string">"text"</span>]];
    
    <span class="regexp">//</span> Connect to a specific host
    [<span class="keyword">debugger</span> <span class="attribute">connectToURL</span>:[NSURL <span class="attribute">URLWithString</span>:@<span class="string">"ws://localhost:9000/device"</span>]];
    <span class="regexp">//</span> Or auto connect via bonjour discovery
    <span class="regexp">//</span>[<span class="keyword">debugger</span> autoConnect];
    <span class="regexp">//</span> Or to a specific ponyd bonjour service
    <span class="regexp">//</span>[<span class="keyword">debugger</span> <span class="attribute">autoConnectToBonjourServiceNamed</span>:@<span class="string">"MY PONY"</span>];

    <span class="regexp">//</span> Enable remote logging to the DevTools Console via PDLog()/PDLogObjects().
    [<span class="keyword">debugger</span> enableRemoteLogging];
    
<span class="comment">#endif</span>
</pre></td></tr></table></figure>

<p>Chrome看到网页显示如下说明连接成功：</p>
<p><img src="http://ww4.sinaimg.cn/large/674a21d2gw1eemkgp4t9rj216c0ea40f.jpg" alt="页面显示"></p>
<p>点击网页中间的应用名即可跳转到debug工具</p>
<h2 id="-">实现原理</h2>
<p>简单看了一下PonyDebugger的源码，服务端使用Tornado框架提供WebSocket服务，客户端则是基于Square自家开源的SocketRocket，关于WebSocket相关的知识，可以参考我之前的这篇<a href="http://shiningio.com/2014/03/16/build-real-time-app-with-websocket/" target="_blank">博文</a>。</p>
<p>网络请求抓包功能是通过注入到NSURLConnectionDelegate中实现的，代码如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
</pre></td><td class="code"><pre>+ (<span class="keyword">void</span>)injectIntoAllNSURLConnectionDelegateClasses;
{
    <span class="comment">// Only allow swizzling once.</span>
    <span class="keyword">static</span> <span class="built_in">BOOL</span> swizzled = <span class="literal">NO</span>;
    <span class="keyword">if</span> (swizzled) {
        <span class="keyword">return</span>;
    }
    
    swizzled = <span class="literal">YES</span>;

    <span class="comment">// Swizzle any classes that implement one of these selectors.</span>
    <span class="keyword">const</span> SEL selectors[] = {
        <span class="keyword">@selector</span>(connectionDidFinishLoading:),
        <span class="keyword">@selector</span>(connection:didReceiveResponse:)
    };
    
    <span class="keyword">const</span> <span class="keyword">int</span> numSelectors = <span class="keyword">sizeof</span>(selectors) / <span class="keyword">sizeof</span>(SEL);

    Class *classes = <span class="literal">NULL</span>;
    <span class="built_in">NSInteger</span> numClasses = objc_getClassList(<span class="literal">NULL</span>, <span class="number">0</span>);
    
    <span class="keyword">if</span> (numClasses &gt; <span class="number">0</span>) {
        classes = (__unsafe_unretained Class *)malloc(<span class="keyword">sizeof</span>(Class) * numClasses);
        numClasses = objc_getClassList(classes, numClasses);
        <span class="keyword">for</span> (<span class="built_in">NSInteger</span> classIndex = <span class="number">0</span>; classIndex &lt; numClasses; ++classIndex) {
            Class class = classes[classIndex];
            
            <span class="keyword">if</span> (class_getClassMethod(class, <span class="keyword">@selector</span>(isSubclassOfClass:)) == <span class="literal">NULL</span>) {
                <span class="keyword">continue</span>;
            }
            
            <span class="keyword">if</span> (![class isSubclassOfClass:[<span class="built_in">NSObject</span> class]]) {
                <span class="keyword">continue</span>;
            }
            
            <span class="keyword">if</span> ([class isSubclassOfClass:[PDNetworkDomainController class]]) {
                <span class="keyword">continue</span>;
            }
            
            <span class="keyword">for</span> (<span class="keyword">int</span> selectorIndex = <span class="number">0</span>; selectorIndex &lt; numSelectors; ++selectorIndex) {
                <span class="keyword">if</span> ([class instancesRespondToSelector:selectors[selectorIndex]]) {
                    [<span class="keyword">self</span> injectIntoDelegateClass:class];
                    <span class="keyword">break</span>;
                }
            }
        }
        
        free(classes);
    }
}
</pre></td></tr></table></figure>

<p>从这个实现也可以发现，像ASIHttpRequest这样的直接基于底层CFNetwork封装的库，以及iOS 7中新引入的NSURLSession都是无法抓到请求包的，这种情况下如果需要抓包就只能使用Charles这类工具了。</p>
<p>调试视图功能调用了一些runtime的私有API，部分代码如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td><td class="code"><pre>+ (void)startMonitoringUIViewChanges;
{
    <span class="comment">// Swizzle UIView add/remove methods to monitor changes in the view hierarchy</span>
    <span class="comment">// Only do it once to avoid swapping back if this method is called again</span>
    <span class="value">static</span> dispatch_once_t onceToken;
    <span class="function">dispatch_once(&onceToken, ^{
        Method original, swizzle;
        Class viewClass = [UIView class];

        // Using <span class="function">sel_registerName()</span> because compiler complains about the swizzled selectors not being found.
        original = <span class="function">class_getInstanceMethod(viewClass, @<span class="function">selector(addSubview:)</span>)</span>;
        swizzle = <span class="function">class_getInstanceMethod(viewClass, <span class="function">sel_registerName(<span class="string">"pd_swizzled_addSubview:"</span>)</span>)</span>;
        <span class="function">method_exchangeImplementations(original, swizzle)</span>;
        
        ···
       	        
        original = <span class="function">class_getInstanceMethod(viewClass, @<span class="function">selector(exchangeSubviewAtIndex:withSubviewAtIndex:)</span>)</span>;
        swizzle = <span class="function">class_getInstanceMethod(viewClass, <span class="function">sel_registerName(<span class="string">"pd_swizzled_exchangeSubviewAtIndex:withSubviewAtIndex:"</span>)</span>)</span>;
        <span class="function">method_exchangeImplementations(original, swizzle)</span>;
    })</span>;
}
</pre></td></tr></table></figure>

<p>这部分可以看到是通过Method Swizzling来动态交换了UIView的方法实现，以addSubview为例，替换成了pd_swizzled_addSubview，至于pd_swizzled_addSubview的实现请看下面</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre>- (void)pd_swizzled_addSubview<span class="value">:(UIView *)subview;</span>
{
    <span class="attr_selector">[[PDDOMDomainController defaultInstance]</span> removeView<span class="value">:subview];</span>
    <span class="attr_selector">[self pd_swizzled_addSubview:subview]</span>;
    <span class="attr_selector">[[PDDOMDomainController defaultInstance]</span> addView<span class="value">:subview];</span>
}
</pre></td></tr></table></figure>

<p>替换后的removeView和addView方法都是重新实现的，里面会将UIView的变动以DOM形式写到PDDOMDomain对象中输出。</p>
<p>除了以上两个主要功能，还有Core Data远程调试，日志远程输出等功能，其实现方式大同小异，就不一一赘述了。</p>
<p>总的来说，PonyDebugger的功能还是十分强大的，也能够有效地提高开发者的调试效率，有类似需求的很值得一试。</p>
]]></content>
    <summary type="html"><![CDATA[<h2 id="-">前言</h2>
<p>Debug算是开发者的基本技能之一吧，对于iOS开发者而言，可能会遇到如下一些debug需求：</p>
<ul>
<li>调试网络请求问题</li>
<li>调试一个层次结构复杂的用户界面</li>
<li>查看应用内Core Data数据变化</li>
</ul>
<p>虽然你可以通过NSLog日志，打断点，抑或LLDB的调试命令等一些常见手段来解决以上问题，但这些方式始终不够直观，效率也不高，特别是对于调试UI这个需求。要提高效率，我们可以使用一些第三方的调试工具，比如本文要介绍的PonyDebugger。</p>
]]></summary>
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[基于WebSocket构建移动端实时应用]]></title>
    <link href="http://yoursite.com/2014/03/16/build-real-time-app-with-websocket/"/>
    <id>http://yoursite.com/2014/03/16/build-real-time-app-with-websocket/</id>
    <published>2014-03-16T11:37:59.000Z</published>
    <updated>2014-03-16T11:37:59.000Z</updated>
    <content type="html"><![CDATA[<h2 id="-">前言</h2>
<p>对于传统的网络应用，大部分情况下使用的是Http短连接，这意味着你发送一次请求，服务器给你返回响应信息，然后连接就被断掉了。然而现实生活中，很多应用实际上是需要一种实时机制的支持，比如微信，你就需要实时收到对方发送的回复信息。对于应用处于后台的情况下，你可以使用系统级别的推送服务，比如iOS下的APNS和Android下的GCM。应用处于前台时呢，则需要自己去和服务端建立一个Http长连接或者轮询，这种方式对于服务器的性能要求还是比较高的。HTML5中提出了一种新的双向通信协议--WebSocket，本文尝试采用这种技术来实现以上的实时推送功能。</p>
<a id="more"></a>

<h2 id="websocket">WebSocket</h2>
<p>WebSocket是HTML5开始提供的一种在客户端和服务器间持久连接的双向通信网络技术。 WebSocket通信协议于2011年被IETF定为标准 RFC 6455，WebSocketAPI被W3C定为标准。协议本身使用新的ws://URL格式，但它是在标准HTTP上实现的。通过使用HTTP和HTTPS端口，它避免了从Web代理后的网络连接站点时引入的各种问题。HTML5规范不只描述了协议本身，还描述了使用WebSocket编写客户端代码所需要的浏览器API。在WebSocket API中，浏览器和服务器只需要做一个握手的动作，然后，浏览器和服务器之间就形成了一条快速通道。两者之间就直接可以数据互相传送。</p>
<h2 id="-">服务端实现</h2>
<p>服务端采用了Facebook开源的<a href="https://github.com/facebook/tornado" target="_blank">Tornado</a>框架，由于Tornado原生支持WebSocket协议，用它来实现服务端非常方便。</p>
<p>Tornado在WebSocket模块中提供了一个WebSocketHandler类。这个类提供了和已连接的客户端通信的WebSocket事件和方法的钩子。当一个新的WebSocket连接打开时，open方法被调用，而on_message和on_close方法分别在连接接收到新的消息和客户端关闭时被调用。</p>
<p>此外，WebSocketHandler类还提供了write_message方法用于向客户端发送消息，close方法用于关闭连接。</p>
<p>以开关状态改变检测为例，服务端部署的代码如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td><td class="code"><pre><span class="class"><span class="keyword">class</span> <span class="title">Switch</span><span class="params">(BaseModel)</span>:</span>
    __tablename__ = <span class="string">'switch'</span>      

    id = Column(Integer, primary_key = <span class="keyword">True</span>)
    name = Column(String(<span class="number">30</span>))
    status = Column(Boolean, server_default = text(<span class="string">'False'</span>)) <span class="comment">#开关当前状态</span>
    level = Column(Integer)                                  <span class="comment">#最小可操作等级</span>

    callbacks = []
    <span class="decorator">@classmethod</span>
    <span class="function"><span class="keyword">def</span> <span class="title">register</span><span class="params">(cls, callback)</span>:</span>
        cls.callbacks.append(callback)

    <span class="decorator">@classmethod</span>
    <span class="function"><span class="keyword">def</span> <span class="title">unregister</span><span class="params">(cls, callback)</span>:</span>
        cls.callbacks.remove(callback)

    <span class="function"><span class="keyword">def</span> <span class="title">notifyCallbacks</span><span class="params">(self)</span>:</span>
        <span class="keyword">for</span> callback <span class="keyword">in</span> self.callbacks:
            callback(self.id,self.status)
</pre></td></tr></table></figure>

<p>以上是封装的开关对象，使用了SQLAlchemy作为ORM，其中BaseModel是继承自declarative_base。
定义了两个类方法，分别是注册和移除回调，另外一个实例方法来通知回调。</p>
<p>对外处理请求的handler:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre><span class="class"><span class="keyword">class</span> <span class="title">GetSwitchStatusHandler</span><span class="params">(BaseWebsockHandler)</span>:</span>

    <span class="function"><span class="keyword">def</span> <span class="title">open</span><span class="params">(self)</span>:</span>
        Switch.register(self.callback)

    <span class="function"><span class="keyword">def</span> <span class="title">on_close</span><span class="params">(self)</span>:</span>
        Switch.unregister(self.callback)
			
    <span class="function"><span class="keyword">def</span> <span class="title">on_message</span><span class="params">(self,msg)</span>:</span>
        <span class="keyword">pass</span>

    <span class="function"><span class="keyword">def</span> <span class="title">callback</span><span class="params">(self,switch_id,status)</span>:</span>
        self.write_message(<span class="string">'{"switch_id":"%s","status":"%d"}'</span>%(switch_id,status))
</pre></td></tr></table></figure>

<p>BaseWebsockHandler继承自tornado.websocket.WebSocketHandler，在initialize中对于SQLAlchemy的session进行了初始化</p>
<p>由于在本例中不需要取客户端的上行消息，故直接pass调了on_message方法。callback方法则用来处理回调，将改变后的开关信息返回给客户端。</p>
<h2 id="-">客户端实现</h2>
<p>客户端使用了Square开源的<a href="https://github.com/square/SocketRocket" target="_blank">SocketRocket</a>。</p>
<p>在iOS工程中安装可以直接使用源码，也可以用CocoaPods安装，将以下依赖加入到PodFile中，再执行install命令即可</p>
<p><code>pod &#39;SocketRocket&#39;, &#39;~&gt; 0.3.1-beta2&#39;</code></p>
<p>SocketRocket的核心是SRWebSocket这个类，需要在使用WebSocket连接的ViewController中实现SRWebSocketDelegate。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre></td><td class="code"><pre>- (<span class="keyword">void</span>)connect{
    
    webSocket<span class="variable">.delegate</span> = <span class="literal">nil</span>;
    [webSocket close]; 
    webSocket = [[SRWebSocket alloc] initWithURLRequest:[<span class="built_in">NSURLRequest</span> requestWithURL:[<span class="built_in">NSURL</span> URLWithString:SWITCH_STATUS_URL]]];
    webSocket<span class="variable">.delegate</span> = <span class="keyword">self</span>;
    <span class="built_in">NSLog</span>(@<span class="string">"Opening Connection..."</span>);
    [webSocket open];
}

···

pragma mark - SRWebSocketDelegate

- (<span class="keyword">void</span>)webSocketDidOpen:(SRWebSocket *)webSocket;{
    <span class="built_in">NSLog</span>(@<span class="string">"Websocket Connected"</span>);
}

- (<span class="keyword">void</span>)webSocket:(SRWebSocket *)webSocket didFailWithError:(<span class="built_in">NSError</span> *)error;{
    <span class="built_in">NSLog</span>(@<span class="string">":( Websocket Failed With Error %@"</span>, error);
    webSocket = <span class="literal">nil</span>;
}

- (<span class="keyword">void</span>)webSocket:(SRWebSocket *)webSocket didReceiveMessage:(<span class="keyword">id</span>)message;{
    <span class="built_in">NSLog</span>(@<span class="string">"Received \"%@\""</span>, message);
}

- (<span class="keyword">void</span>)webSocket:(SRWebSocket *)webSocket didCloseWithCode:(<span class="built_in">NSInteger</span>)code reason:(<span class="built_in">NSString</span> *)reason wasClean:(<span class="built_in">BOOL</span>)wasClean;{
    <span class="built_in">NSLog</span>(@<span class="string">"WebSocket closed"</span>);
    webSocket = <span class="literal">nil</span>;
}
</pre></td></tr></table></figure>

<p>把delegate指向自身，然后调用SRWebSocket中的方法发送请求即可。
收到下行消息会调用didReceiveMessage这个方法，如果需要在请求时携带参数，可以用类似get请求的方法，将请求放在url字符串中。</p>
<p>到此为止WebSocket的基本功能就实现完毕了，完整demo可以参考我的<a href="https://github.com/cmjman?tab=repositories" target="_blank">Github</a>。</p>
<h2 id="-">参考</h2>
<p>《Introduction to Tornado》<a href="http://book.douban.com/subject/7906788/" target="_blank">http://book.douban.com/subject/7906788/</a></p>
]]></content>
    <summary type="html"><![CDATA[<h2 id="-">前言</h2>
<p>对于传统的网络应用，大部分情况下使用的是Http短连接，这意味着你发送一次请求，服务器给你返回响应信息，然后连接就被断掉了。然而现实生活中，很多应用实际上是需要一种实时机制的支持，比如微信，你就需要实时收到对方发送的回复信息。对于应用处于后台的情况下，你可以使用系统级别的推送服务，比如iOS下的APNS和Android下的GCM。应用处于前台时呢，则需要自己去和服务端建立一个Http长连接或者轮询，这种方式对于服务器的性能要求还是比较高的。HTML5中提出了一种新的双向通信协议--WebSocket，本文尝试采用这种技术来实现以上的实时推送功能。</p>
]]></summary>
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[从JSONModel看Objective-C的反射机制]]></title>
    <link href="http://yoursite.com/2014/03/14/see-reflection-of-ios-from-jsonmodel/"/>
    <id>http://yoursite.com/2014/03/14/see-reflection-of-ios-from-jsonmodel/</id>
    <published>2014-03-14T11:35:37.000Z</published>
    <updated>2014-03-14T11:35:37.000Z</updated>
    <content type="html"><![CDATA[<h2 id="-">前言</h2>
<p>移动互联时代，JSON作为一种数据传输格式几乎随处可见。作为iOS开发者，收到一串JSON字符串要怎么处理？我想多数情况下是需要将它转成自定义的NSObject对象再使用，对于这个转换的过程，大部分人是这么做的:</p>
<a id="more"></a>

<figure class="highlight [objc]"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre>NSDictionary* json = (fetch from Internet) <span class="keyword">...</span>
User* user=[[User alloc] init];
user.userId =[json objectForKey:@<span class="string">"userId"</span>];
user.nick= [json objectForKey:@<span class="string">"nick"</span>];
user.image = [json objectForKey:@<span class="string">"image"</span>];
user.age = [json objectForKey:@<span class="string">"age"</span>];
<span class="keyword">...</span>
</pre></td></tr></table></figure>

<p>这样的代码没错，但也绝对说不上优雅，model里面的属性越多，冗余的代码量也相应越多。对于这个问题，自然是有更好的解决方案，比如说这样:</p>
<figure class="highlight [objc]"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>NSError* <span class="built_in">err</span> = nil;
User* user = [[User alloc] initWithDictionary:json <span class="keyword">error</span>:&<span class="built_in">err</span>];
</pre></td></tr></table></figure>

<p>两行代码足矣，当然，实现这个功能，实际上是把很多背后的工作交给<a href="https://github.com/icanzilb/JSONModel" target="_blank">JSONModel</a>这个开源包去做了。至于其实现原理，则主要是基于<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/ObjCRuntimeRef/Reference/reference.html" target="_blank">Objective-C Runtime</a>的反射机制。</p>
<h2 id="-">关于反射</h2>
<p>《Thinking in Java》中将反射称解释为<strong>运行时的类信息</strong>，说白了就是这个类信息在编译的时候是未知的，需要在程序运行期间动态获取，而这正是我们之前试图去解决的问题。对于从网络上获取到的一段JSON字符串，在代码编译期间当然是无法知晓的。虽然这里说的是Java语言，但是对于Objective-C，这种反射机制也是同样支持的。</p>
<h2 id="jsonmodel-">JSONModel中的实现</h2>
<p>打断点记录了下JSONModel这个类中的方法调用顺序如下：</p>
<p><img src="http://ww2.sinaimg.cn/large/674a21d2jw1eefi8g36hrj209l02lmx4.jpg" alt="调用顺序"></p>
<p>对象属性的获取则主要在最后一个inspectProperties方法</p>
<p>以下是inspectProperties方法的代码片段：</p>
<figure class="highlight [objc]"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
</pre></td><td class="code"><pre>···

<span class="comment">//inspects the class, get's a list of the class properties</span>
-(<span class="keyword">void</span>)__inspectProperties
{
    <span class="comment">//JMLog(@"Inspect class: %@", [self class]);</span>
    
    <span class="built_in">NSMutableDictionary</span>* propertyIndex = [<span class="built_in">NSMutableDictionary</span> dictionary];
    
    <span class="comment">//temp variables for the loops</span>
    Class class = [<span class="keyword">self</span> class];
    NSScanner* scanner = <span class="literal">nil</span>;
    <span class="built_in">NSString</span>* propertyType = <span class="literal">nil</span>;
    
    <span class="comment">// inspect inherited properties up to the JSONModel class</span>
    <span class="keyword">while</span> (class != [JSONModel class]) {
        <span class="comment">//JMLog(@"inspecting: %@", NSStringFromClass(class));</span>
        
        <span class="keyword">unsigned</span> <span class="keyword">int</span> propertyCount;
        objc_property_t *properties = class_copyPropertyList(class, &propertyCount);
        
        <span class="comment">//loop over the class properties</span>
        <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; propertyCount; i++) {

            JSONModelClassProperty* p = [[JSONModelClassProperty alloc] init];

            <span class="comment">//get property name</span>
            objc_property_t property = properties[i];
            <span class="keyword">const</span> <span class="keyword">char</span> *propertyName = property_getName(property);
            p<span class="variable">.name</span> = [<span class="built_in">NSString</span> stringWithUTF8String:propertyName];
            
            <span class="comment">//JMLog(@"property: %@", p.name);</span>
            
            <span class="comment">//get property attributes</span>
            <span class="keyword">const</span> <span class="keyword">char</span> *attrs = property_getAttributes(property);
            <span class="built_in">NSString</span>* propertyAttributes = [<span class="built_in">NSString</span> stringWithUTF8String:attrs];
            
            <span class="keyword">if</span> ([propertyAttributes hasPrefix:@<span class="string">"Tc,"</span>]) {
                <span class="comment">//mask BOOLs as structs so they can have custom convertors</span>
                p<span class="variable">.structName</span> = @<span class="string">"BOOL"</span>;
            }
            
            scanner = [NSScanner scannerWithString: propertyAttributes];
            
            <span class="comment">//JMLog(@"attr: %@", [NSString stringWithCString:attrs encoding:NSUTF8StringEncoding]);</span>
            [scanner scanUpToString:@<span class="string">"T"</span> intoString: <span class="literal">nil</span>];
            [scanner scanString:@<span class="string">"T"</span> intoString:<span class="literal">nil</span>];

···

<span class="comment">//finally store the property index in the static property index</span>
objc_setAssociatedObject(<span class="keyword">self</span><span class="variable">.class</span>,
                         &kClassPropertiesKey,
                         [propertyIndex copy],
                         OBJC_ASSOCIATION_RETAIN <span class="comment">// This is atomic</span>
                         );
</pre></td></tr></table></figure>

<p>在这边可以看到基本步骤如下</p>
<ol>
<li>通过调用自身的class方法获取当前类的元数据信息</li>
<li>通过runtime的 class_copyPropertyList 方法取得当前类的属性列表，以指针数组的形式返回</li>
<li>遍历指针数组，通过property_getName获取属性名，property_getAttributes获取属性类型</li>
<li>使用NSScanner来扫描属性类型字符串，将类似如下的形式&quot;T@&quot;NSNumber&quot;,&amp;,N,V_id&quot;，处理成NSNumber，逐个属性循环处理</li>
<li>将所有处理好的数据放入propertyIndex这个字典中</li>
<li>通过objc_setAssociatedObject将这些数据关联到kClassPropertiesKey</li>
</ol>
<p>使用时在<strong>properties</strong>方法中这样取出属性数据：</p>
<figure class="highlight [objc]"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="code"><pre><span class="comment">//returns a list of the model's properties</span>
-(<span class="built_in">NSArray</span>*)__properties__
{
    <span class="comment">//fetch the associated object</span>
    <span class="built_in">NSDictionary</span>* classProperties = objc_getAssociatedObject(<span class="keyword">self</span><span class="variable">.class</span>, &kClassPropertiesKey);
    <span class="keyword">if</span> (classProperties) <span class="keyword">return</span> [classProperties allValues];

    <span class="comment">//if here, the class needs to inspect itself</span>
    [<span class="keyword">self</span> __setup__];
    
    <span class="comment">//return the property list</span>
    classProperties = objc_getAssociatedObject(<span class="keyword">self</span><span class="variable">.class</span>, &kClassPropertiesKey);
    <span class="keyword">return</span> [classProperties allValues];
}
</pre></td></tr></table></figure>

<p>以上就是JSONModel中使用反射机制实现的类属性获取过程，相比常见的逐个取值赋值的方式，这种方法在代码上的确简洁优雅了很多，特别是对于使用的类属性比较复杂的情况，免除了很多不必要的代码。</p>
]]></content>
    <summary type="html"><![CDATA[<h2 id="-">前言</h2>
<p>移动互联时代，JSON作为一种数据传输格式几乎随处可见。作为iOS开发者，收到一串JSON字符串要怎么处理？我想多数情况下是需要将它转成自定义的NSObject对象再使用，对于这个转换的过程，大部分人是这么做的:</p>
]]></summary>
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[初学AFNetworking网络通信类库]]></title>
    <link href="http://yoursite.com/2014/03/09/getting-started-with-afnetworking/"/>
    <id>http://yoursite.com/2014/03/09/getting-started-with-afnetworking/</id>
    <published>2014-03-09T12:27:25.000Z</published>
    <updated>2014-03-09T12:27:25.000Z</updated>
    <content type="html"><![CDATA[<h2 id="-">前言</h2>
<p>从Android转过来学iOS开发也快一年了，之前在公司的几个项目在网络通信方面都是使用的ASIHttpRequest。ASI很稳定，效率也不错，可惜的是这个开源项目已经停止更新多年了，甚至连ARC也不支持。手机淘宝这样比较早的项目，大多是基于ASI自己做了一层浅的封装，貌似去年有经过一次大的重构，不过ASI还是留下了。对于ASI这类处于相对底层的依赖库，老项目迁移的成本的确太大了。</p>
<a id="more"></a>

<p>之前在开发中也会遇到Profile检测出的内存泄漏，发现不少都是来自ASI，虽然对于单个的内存泄漏而言并不算多，但积少成多总是个问题。加之iOS系统的不断更新，一个不更新的类库难免会跟不上时代。综合考虑之下，觉得现在新起的项目还是使用AFNetworking更好一点。于是，特地抽空学了一下<a href="https://github.com/AFNetworking/AFNetworking" target="_blank">AFNetworking</a>这个类库的基本使用。</p>
<h2 id="-">概览</h2>
<p>根据源码里面的类结构，简单画了下AFNetworking的结构图
<img src="http://ww3.sinaimg.cn/large/674a21d2gw1ee9oop21gcj20h40e475j.jpg" alt="AFNetworking"></p>
<p>如上图，AFNetworking有5个主要的包。</p>
<ul>
<li>NSURLConnection 核心的网络请求功能，继承自NSOperation</li>
<li>NSURLSession 针对iOS7新增的后台多任务（Multitasking），可以在后台进行数据下载等处理</li>
<li>Security 针对SSL Pinning的封装，用于防止中间人攻击</li>
<li>Reachablity 用于检测网络状况</li>
<li>Serizalization 可序列化的Request和Response对象封装</li>
</ul>
<h2 id="-">基本网络请求</h2>
<p>官方推荐优先使用AFHTTPRequestOperationManager进行网络请求。</p>
<h3 id="get-">Get 请求</h3>
<figure class="highlight [objc]"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre>AFHTTPRequestOperationManager *manager = [AFHTTPRequestOperationManager manager];
[manager GET:@<span class="string">"http://example.com/resources.json"</span> parameters:<span class="literal">nil</span> success:^(AFHTTPRequestOperation *operation, <span class="keyword">id</span> responseObject) {
    <span class="built_in">NSLog</span>(@<span class="string">"JSON: %@"</span>, responseObject);
} failure:^(AFHTTPRequestOperation *operation, <span class="built_in">NSError</span> *error) {
    <span class="built_in">NSLog</span>(@<span class="string">"Error: %@"</span>, error);
}];
</pre></td></tr></table></figure>

<h3 id="post-url-form-encoded-">POST请求(URL-Form-Encoded)</h3>
<figure class="highlight [objc]"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre>AFHTTPRequestOperationManager *manager = [AFHTTPRequestOperationManager manager];
<span class="built_in">NSDictionary</span> *parameters = @{@<span class="string">"foo"</span>: @<span class="string">"bar"</span>};
[manager POST:@<span class="string">"http://example.com/resources.json"</span> parameters:parameters success:^(AFHTTPRequestOperation *operation, <span class="keyword">id</span> responseObject) {
    <span class="built_in">NSLog</span>(@<span class="string">"JSON: %@"</span>, responseObject);
} failure:^(AFHTTPRequestOperation *operation, <span class="built_in">NSError</span> *error) {
    <span class="built_in">NSLog</span>(@<span class="string">"Error: %@"</span>, error);
}];
</pre></td></tr></table></figure>

<h3 id="post-multi-part-">POST请求(Multi-Part)</h3>
<figure class="highlight [objc]"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre>AFHTTPRequestOperationManager *manager = [AFHTTPRequestOperationManager manager];
<span class="built_in">NSDictionary</span> *parameters = @{@<span class="string">"foo"</span>: @<span class="string">"bar"</span>};
<span class="built_in">NSURL</span> *filePath = [<span class="built_in">NSURL</span> fileURLWithPath:@<span class="string">"file://path/to/image.png"</span>];
[manager POST:@<span class="string">"http://example.com/resources.json"</span> parameters:parameters constructingBodyWithBlock:^(<span class="keyword">id</span>&lt;AFMultipartFormData&gt; formData) {
    [formData appendPartWithFileURL:filePath name:@<span class="string">"image"</span> error:<span class="literal">nil</span>];
} success:^(AFHTTPRequestOperation *operation, <span class="keyword">id</span> responseObject) {
    <span class="built_in">NSLog</span>(@<span class="string">"Success: %@"</span>, responseObject);
} failure:^(AFHTTPRequestOperation *operation, <span class="built_in">NSError</span> *error) {
    <span class="built_in">NSLog</span>(@<span class="string">"Error: %@"</span>, error);
}];
</pre></td></tr></table></figure>

<h3 id="-">批量请求</h3>
<p>针对一次性要发送多个请求的情况，可以使用AFURLConnectionOperation。</p>
<figure class="highlight [objc]"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="code"><pre><span class="built_in">NSMutableArray</span> *mutableOperations = [<span class="built_in">NSMutableArray</span> array];
<span class="keyword">for</span> (<span class="built_in">NSURL</span> *fileURL in filesToUpload) {
    <span class="built_in">NSURLRequest</span> *request = [[AFHTTPRequestSerializer serializer] multipartFormRequestWithMethod:@<span class="string">"POST"</span> URLString:@<span class="string">"http://example.com/upload"</span> parameters:<span class="literal">nil</span> constructingBodyWithBlock:^(<span class="keyword">id</span>&lt;AFMultipartFormData&gt; formData) {
        [formData appendPartWithFileURL:fileURL name:@<span class="string">"images[]"</span> error:<span class="literal">nil</span>];
    }];

    AFHTTPRequestOperation *operation = [[AFHTTPRequestOperation alloc] initWithRequest:request];

    [mutableOperations addObject:operation];
}

<span class="built_in">NSArray</span> *operations = [AFURLConnectionOperation batchOfRequestOperations:@[...] progressBlock:^(NSUInteger numberOfFinishedOperations, NSUInteger totalNumberOfOperations) {
    <span class="built_in">NSLog</span>(@<span class="string">"%lu of %lu complete"</span>, numberOfFinishedOperations, totalNumberOfOperations);
} completionBlock:^(<span class="built_in">NSArray</span> *operations) {
    <span class="built_in">NSLog</span>(@<span class="string">"All operations in batch complete"</span>);
}];
[[NSOperationQueue mainQueue] addOperations:operations waitUntilFinished:<span class="literal">NO</span>];
</pre></td></tr></table></figure>

<h2 id="-ios7-">后台多任务（iOS7新特性）</h2>
<p>针对iOS 7新的Multitasking特性，系统提供了NSURLSession这个新的网络接口，这个接口与原有的NSURLConnection实际上是并列的。程序处于前台运行状态中，这两者可以互相替代，在程序处于后台时，使用这个新接口可以免于被系统自动截断数据传输，一般用于后台下载功能，AFNetworking2.0开始针对这个接口进行了封装。</p>
<p>示例代码：</p>
<figure class="highlight [objc]"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre>NSURLSessionConfiguration *configuration = [NSURLSessionConfiguration defaultSessionConfiguration];
AFURLSessionManager *manager = [[AFURLSessionManager alloc] initWithSessionConfiguration:configuration];

<span class="built_in">NSURL</span> *URL = [<span class="built_in">NSURL</span> URLWithString:@<span class="string">"http://example.com/download.zip"</span>];
<span class="built_in">NSURLRequest</span> *request = [<span class="built_in">NSURLRequest</span> requestWithURL:URL];

NSURLSessionDownloadTask *downloadTask = [manager downloadTaskWithRequest:request progress:<span class="literal">nil</span> destination:^<span class="built_in">NSURL</span> *(<span class="built_in">NSURL</span> *targetPath, NSURLResponse *response) {
    <span class="built_in">NSURL</span> *documentsDirectoryPath = [<span class="built_in">NSURL</span> fileURLWithPath:[NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, <span class="literal">YES</span>) firstObject]];
    <span class="keyword">return</span> [documentsDirectoryPath URLByAppendingPathComponent:[response suggestedFilename]];
} completionHandler:^(NSURLResponse *response, <span class="built_in">NSURL</span> *filePath, <span class="built_in">NSError</span> *error) {
    <span class="built_in">NSLog</span>(@<span class="string">"File downloaded to: %@"</span>, filePath);
}];
[downloadTask resume];
</pre></td></tr></table></figure>

<h2 id="-">实时推送</h2>
<p>在<a href="http://cocoadocs.org/" target="_blank">CocoaDocs</a>查看文档的时候发现在2.0RC版中是带有AFEventSource的，在2.0正式版之后似乎把这个模块给独立出来了，Github上AFNetworking的主项目是没有该特性的，而是放到了<a href="https://github.com/AFNetworking/AFRocketClient" target="_blank">AFRocketClient</a>这个子项目中。</p>
<p>AFEventSource实际上是基于OC实现的<a href="http://en.wikipedia.org/wiki/Server-sent_events" target="_blank">EventSource DOM API</a>，其本质是在客户端和服务端之间建立长连接进行实时推送。</p>
<p>示例代码：</p>
<figure class="highlight [objc]"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre><span class="built_in">NSURL</span> *URL = [<span class="built_in">NSURL</span> URLWithString:@<span class="string">"http://example.com"</span>];
AFRocketClient *client = [[AFRocketClient alloc] init];
[client SUBSCRIBE:@<span class="string">"/resources"</span> usingBlock:^(<span class="built_in">NSArray</span> *operations, <span class="built_in">NSError</span> *error) {
    <span class="keyword">for</span> (AFJSONPatchOperation *operation in operations) {
        <span class="keyword">switch</span> (operation<span class="variable">.type</span>) {
            <span class="keyword">case</span> AFJSONAddOperationType:
                [resources addObject:operation<span class="variable">.value</span>];
                <span class="keyword">break</span>;
            <span class="keyword">default</span>:
                <span class="keyword">break</span>;
        }
    }
} error:<span class="literal">nil</span>]
</pre></td></tr></table></figure>

]]></content>
    <summary type="html"><![CDATA[<h2 id="-">前言</h2>
<p>从Android转过来学iOS开发也快一年了，之前在公司的几个项目在网络通信方面都是使用的ASIHttpRequest。ASI很稳定，效率也不错，可惜的是这个开源项目已经停止更新多年了，甚至连ARC也不支持。手机淘宝这样比较早的项目，大多是基于ASI自己做了一层浅的封装，貌似去年有经过一次大的重构，不过ASI还是留下了。对于ASI这类处于相对底层的依赖库，老项目迁移的成本的确太大了。</p>
]]></summary>
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[通过Hexo初始化源码学习Node.js]]></title>
    <link href="http://yoursite.com/2014/03/06/learn-nodejs-with-hexo-source-code/"/>
    <id>http://yoursite.com/2014/03/06/learn-nodejs-with-hexo-source-code/</id>
    <published>2014-03-06T11:12:29.000Z</published>
    <updated>2014-03-06T11:12:29.000Z</updated>
    <content type="html"><![CDATA[<h2 id="-">前言</h2>
<p>静态博客这个东西，在国内应该是12年开始兴起的，个人最早是通过阮一峰的<a href="http://www.ruanyifeng.com/blog/2012/08/blogging_with_jekyll.html" target="_blank">这篇博客</a>才了解到Jekyll。Jekyll虽然很简洁，但有个问题是操作比较繁杂，于是后来就有了基于Ruby自动生成静态页面的Octopress，以及本博客使用的基于Node.js的Hexo。</p>
<a id="more"></a>

<p>算起来自己也是多年的老网民，曾开过不少博客，包括之前门户型博客尚火的时候使用过网易，新浪，博客大巴之类的服务，后来进入到云时代，又曾在SAE上搭建过Wordpress，不过这众多博客最终都不了了之。一方面是使用第三方的服务毕竟存在着诸多限制，另一方面也确实是肚子里的墨水有限，开始的兴趣头玩过去后，就没啥好写了。</p>
<p>去年开始进入企业实习之后，一个迫切的感觉是需要一个地方去记录平时的学习和思考。并且博客也是一个非常好的树立个人品牌效应的地方。于是在年初又开始折腾博客了，对现有的静态博客系统进行了一个全面的体验，发现Octopress的确很方便，而且生态也比较成熟，相关的插件多。但有个问题是，当博客文章较多的时候生成静态页面会很慢，后来在知乎发现Hexo这个后起之秀，体验了一番，感觉很不错。基于Node.js的实现，在性能上比起Ruby有很大优势，于是最终就选定了这个系统使用。</p>
<p>关于Node.js，其实之前并没有很深入的了解，只是知道一些基本的概念知识。当然，如果仅仅是搭建静态博客，甚至可以完全不去了解该系统的构建语言，敲敲命令行就可以了。不过作为一个程序员，使用一个开源东西，还是有必要做一些了解的，于是怀着学习的态度，大致浏览了一下Hexo的源码。</p>
<h2 id="node-js-">Node.js基础概念</h2>
<p>先来了解一下一些Node.js的基本概念。</p>
<h3 id="-">模块</h3>
<p>模块是构成Node应用的组件，在Node中每个JS文件相当于一个模块，可以通过require语句引入模块。如果之前有Python/Ruby这类脚本语言经验的应该很好理解。</p>
<h3 id="npm-">NPM包管理器</h3>
<p>npm实际上是一个Node包管理和分发工具，类似Python的pip或者Ruby的gem。一个npm包是包含了package.json的文件夹，该文件描述了文件夹的结构。可以使用search命令搜索包，install命令来安装相应的包。Hexo就是一个已经发布到npm上的包。</p>
<h2 id="-">初始化部分源码浅析</h2>
<p>Hexo开源地址 <a href="https://github.com/tommy351/hexo" target="_blank">https://github.com/tommy351/hexo</a></p>
<p>分析的源码基于Hexo 2.2.1，取自Github上的开源主干。</p>
<p><img src="http://ww1.sinaimg.cn/large/674a21d2gw1ee65g1gl2tj21kw16w12a.jpg" alt="代码结构"></p>
<p>在package.json文件中可以看到Hexo使用了async,express,ejs等常见Node框架和引擎。</p>
<p>assets文件夹下面预置了markdown页面的模板，以及默认的配置文件，主题文件等等，hexo的核心代码则都在lib文件夹下面。</p>
<p>bin文件夹中有一个hexo文件，安装后被放在系统环境变量中，终端输入的hexo即直接调用该文件。
该文件中仅有1行代码</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="keyword">require</span>(<span class="string">'../lib/init'</span>)(process.cwd(), <span class="keyword">require</span>(<span class="string">'optimist'</span>).argv);
</pre></td></tr></table></figure>

<p>该文件调用了lib下的init文件进行一些初始化工作。
其中第一个参数是控制台传入的命令，第二个参数则是引用了optimist这个命令行参数解析库来处理参数。</p>
<p>在init.js文件的36行可以看到该模块的公开接口，主要是加载了渲染插件以及Log相关操作。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
</pre></td><td class="code"><pre>module.exports = <span class="function"><span class="keyword">function</span><span class="params">(cwd, args, callback)</span>{</span>
  <span class="keyword">var</span> baseDir = cwd,
    hexo = global.hexo = <span class="keyword">new</span> Hexo(baseDir, args, {}),
    log = hexo.log;

  <span class="comment">// Loads plugins</span>
  <span class="built_in">require</span>(<span class="string">'./plugins/swig'</span>);
  <span class="built_in">require</span>(<span class="string">'./plugins/renderer'</span>);

  <span class="comment">// Sets render function</span>
  hexo.render = <span class="built_in">require</span>(<span class="string">'./render'</span>);

  <span class="comment">// Sets logger stream</span>
  <span class="keyword">if</span> (!args._test){
    <span class="keyword">var</span> consoleStream = <span class="keyword">new</span> Logger.stream.Console(log, {
      colors: {
        create: <span class="string">'green'</span>,
        update: <span class="string">'yellow'</span>,
        <span class="keyword">delete</span>: <span class="string">'red'</span>
      }
    });

    <span class="keyword">if</span> (args.debug){
      consoleStream.setFormat(<span class="string">'[:level] '</span> + <span class="string">':date'</span>.grey + <span class="string">' :message'</span>);
      consoleStream.setHide(<span class="number">9</span>);

      <span class="keyword">var</span> logPath = path.join(baseDir, <span class="string">'debug.log'</span>);

      createLogFile(logPath, <span class="function"><span class="keyword">function</span><span class="params">(err)</span>{</span>
        <span class="keyword">if</span> (err) <span class="keyword">return</span> log.e(err);

        <span class="keyword">var</span> fileStream = <span class="keyword">new</span> Logger.stream.File(log, {
          path: logPath,
          hide: <span class="number">9</span>
        });
      });
    }
  }
</pre></td></tr></table></figure>

<p>在init.js的75行执行async.auto，async是一个用于流程处理的工具包，调用auto方法来处理有依赖关系的多个任务的执行。该方法下行有5个任务，分别是：</p>
<ul>
<li>config 从yml配置文件中加载博客配置信息</li>
<li>update 更新package.json中的包依赖</li>
<li>load_plugins 加载插件，这里的插件对应node_modules文件夹下面的一些node模块</li>
<li>load_scripts 加载脚本，自动执行scripts文件夹下的JS文件，用来对hexo作扩展</li>
<li>load_database 加载数据库 使用了Warehouse，这是hexo作者自己实现的一个基于JSON的数据库</li>
</ul>
<p>以上5个任务处理完成之后，会在回调函数中加载hexo本身的一些model和plugins，这些都在lib下面的对应文件夹下，其中包括命令行的入口，它也是以插件形式存在。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
</pre></td><td class="code"><pre><span class="keyword">function</span>(err, results){
    <span class="keyword">if</span> (err) <span class="keyword">return</span> log.e(err);

    var init = results.config;

    <span class="keyword">if</span> (init){
      hexo.init = true;

      // Loads models
      hexo.model.register(<span class="string">'Asset'</span>, <span class="keyword">require</span>(<span class="string">'./model/asset'</span>));
      hexo.model.register(<span class="string">'Cache'</span>, <span class="keyword">require</span>(<span class="string">'./model/cache'</span>));
      hexo.model.register(<span class="string">'Category'</span>, <span class="keyword">require</span>(<span class="string">'./model/category'</span>));
      hexo.model.register(<span class="string">'Page'</span>);
      hexo.model.register(<span class="string">'Post'</span>, <span class="keyword">require</span>(<span class="string">'./model/post'</span>));
      hexo.model.register(<span class="string">'Tag'</span>, <span class="keyword">require</span>(<span class="string">'./model/tag'</span>));
      hexo.model.register(<span class="string">'Token'</span>);

      // Loads plugins
      <span class="keyword">require</span>(<span class="string">'./plugins/tag'</span>);
      <span class="keyword">require</span>(<span class="string">'./plugins/helper'</span>);
      <span class="keyword">require</span>(<span class="string">'./plugins/filter'</span>);
      <span class="keyword">require</span>(<span class="string">'./plugins/processor'</span>);
      <span class="keyword">require</span>(<span class="string">'./plugins/generator'</span>);
      <span class="keyword">require</span>(<span class="string">'./plugins/deployer'</span>);

      hexo.post = <span class="keyword">require</span>(<span class="string">'./post'</span>);
    }

    <span class="keyword">require</span>(<span class="string">'./plugins/console'</span>);

    var command = args._.shift();

    hexo.emit(<span class="string">'ready'</span>);
    <span class="keyword">...</span>
</pre></td></tr></table></figure>

<p>查看/lib/plugins/console发现有以下一些文件：</p>
<ul>
<li>generate 生成静态文件，可以使用g代替</li>
<li>list 显示当前的博客页面结构</li>
<li>server 启动内置的本地服务器进行预览，可以使用s代替</li>
<li>clean 清除缓存</li>
<li>config 显示当前的配置信息</li>
<li>deploy 部署到线上</li>
<li>help 帮助信息</li>
<li>init 初始化新的Hexo文件夹</li>
<li>migrate 从其他系统迁移到hexo的搬家命令，支持RSS，Jekyll，Octopress和WordPress</li>
<li>new 创建新文章，可以使用n代替，默认为post，可选参数为page（新页面）和 draft（草稿）</li>
<li>publishDraft 将草稿箱中的文件发布</li>
<li>render 用于markdown文件渲染</li>
<li>version 显示当前系统版本</li>
</ul>
<p>以上这些文件都有对应的控制台命令，并通过index.js对外注册所有的命令，用于控制台的调用。</p>
<p>回调函数中处理一些收尾工作，如果在退出中出错，会dump一些错误信息log到本地：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre></td><td class="code"><pre>  hexo.call(command, args, <span class="function"><span class="keyword">function</span><span class="params">(err)</span>{</span>
      <span class="keyword">if</span> (err) log.e(err);

      hexo.emit(<span class="string">'exit'</span>);

      <span class="keyword">if</span> (!err) <span class="keyword">return</span> process.<span class="keyword">exit</span>(<span class="number">0</span>);

      <span class="comment">// Dumps error log</span>
      <span class="keyword">var</span> logPath = path.join(baseDir, <span class="string">'debug.log'</span>);

      async.series([
        <span class="function"><span class="keyword">function</span><span class="params">(next)</span>{</span>
          createLogFile(logPath, next);
        },
        <span class="function"><span class="keyword">function</span><span class="params">(next)</span>{</span>
          <span class="keyword">var</span> content = [];

          log.store.<span class="keyword">forEach</span>(<span class="function"><span class="keyword">function</span><span class="params">(item)</span>{</span>
            content.push(Logger.stream.File._toString(<span class="string">'[:level] :date :message'</span>, item));
          });

          fs.appendFile(logPath, content.join(<span class="string">'\n'</span>), next);
        }
      ], <span class="function"><span class="keyword">function</span><span class="params">(err)</span>{</span>
        <span class="keyword">if</span> (err) <span class="keyword">return</span> log.e(err);

        process.<span class="keyword">exit</span>(<span class="number">1</span>);
      });
   });
</pre></td></tr></table></figure>

<p>到此基本上hexo的初始化基本上就执行完毕了。</p>
]]></content>
    <summary type="html"><![CDATA[<h2 id="-">前言</h2>
<p>静态博客这个东西，在国内应该是12年开始兴起的，个人最早是通过阮一峰的<a href="http://www.ruanyifeng.com/blog/2012/08/blogging_with_jekyll.html" target="_blank">这篇博客</a>才了解到Jekyll。Jekyll虽然很简洁，但有个问题是操作比较繁杂，于是后来就有了基于Ruby自动生成静态页面的Octopress，以及本博客使用的基于Node.js的Hexo。</p>
]]></summary>
    
      <category term="Hexo" scheme="http://yoursite.com/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[常见短距无线通信技术概览]]></title>
    <link href="http://yoursite.com/2014/03/05/overview-of-short-distance-wireless-communication-technology/"/>
    <id>http://yoursite.com/2014/03/05/overview-of-short-distance-wireless-communication-technology/</id>
    <published>2014-03-05T05:52:05.000Z</published>
    <updated>2014-03-05T07:21:50.000Z</updated>
    <content type="html"><![CDATA[<h2 id="-">短距无线通信技术</h2>
<p>什么是短距无线通信技术？到目前为止，学术界和工程界对此无严格的定义。一般来说，短距无线通信技术的主要特点是通信距离短，覆盖范围在几十米或上百米之内。无线发射器的发射功率较低，一般小于100mW。工作频率多为免付费，免申请的的全球通用工业、科学、医学频段。短距无线通信的范围很广，一般意义上，只要通信收发双方通过无线电波传输信息，并且传输距离限制在较小范围内，通常是几十米以内，就可以称之为短距无线通信。</p>
<a id="more"></a>

<h2 id="-bluetooth-">蓝牙（Bluetooth）</h2>
<p>蓝牙是一种无线数据与语音通信的开放性全球规范，它以低成本的短距离无线连接为基础，可以为固定的或者移动的终端设备（如笔记本电脑，手机等）提供廉价的接入服务。其实质内容是为固定设备或移动设备之间的通信环境建立通用的近距无线接口，将通信技术与计算机技术结合起来，使各种设备在没有电线或者电缆相互连接的情况下，能在近距离范围内实现相互通信或操作。其传输频段为全球通用的2.4GHz ISM（Industrial Scientific Medical）频段，提供1Mbps的传输速率和10m的传输距离。</p>
<p>蓝牙协议的标准版本为IEEE 802.15.1，基于蓝牙规范V1.1实现，后者已经构建到现行的很多蓝牙设备中。从目前的应用来看，由于蓝牙体积小、功率低，其应用已不局限于计算机外设，几乎可以被集成到任何数字设备之中，特别是那些对数据传输要求不高的移动设备和便携设备。</p>
<p>蓝牙技术的特点归纳为如下几点：</p>
<ul>
<li>全球范围适用</li>
<li>可同时传输语言和数据</li>
<li>可以建立临时性的对等连接（Ad hoc Connection）</li>
<li>具有很好的抗干扰能力</li>
<li>蓝牙模块体积很小，便于集成</li>
<li>低功耗</li>
<li>开放的接口标准</li>
<li>成本低</li>
</ul>
<h2 id="wi-fi">Wi-Fi</h2>
<p>Wi-Fi（Wireless Fidelity，无线保真）技术和蓝牙一样，同属于在办公室和家庭中使用的短距无线技术。该技术使用2.4GHz附近的频段，该频段是无须申请的ISM无线频段。其目前可使用的标准有两个，分别是IEEE 802.11a 和 IEEE 802.11b。</p>
<p>Wi-Fi技术的优点如下：</p>
<ul>
<li>无线电波的覆盖范围广，相对蓝牙的小范围，Wi-Fi覆盖半径可以达到100m左右。</li>
<li>传输数据很快，最高可达11Mbps。</li>
<li>厂商进入该领域的门槛低。</li>
</ul>
<h2 id="irda">IrDA</h2>
<p>IrDA是一种利用红外线进行点对点通信的技术，是第一个实现无线个域网（Wireless Personal Area Network,WPAN）的技术。目前它的软硬件技术都很成熟，在小型移动设备中使用较广泛。</p>
<p>IrDA在技术上的主要优点有：</p>
<ul>
<li>无需专门申请特定频率的使用执照。</li>
<li>具有移动通信设备所必须的体积小、功率低、连接方便、简单移动的特点，在同类技术中是耗电量最低的。</li>
<li>传输速率在适合于家庭和办公室使用的微微网（Piconet）中是最高的，由于采用点到点的连接，数据传输所受干扰较少，速率可达16Mbps。</li>
<li>红外线发射角度较小（30°以内），传输安全性高。</li>
</ul>
<p>但是，IrDA同时也是一种缺点比较明显的技术。首先，IrDA是一种视距传输技术，也就是说两个具有IrDA端口的设备之间如果传输数据，中间就不能有阻挡物，这在多个电子设备间时就需要调整彼此的角度和位置。其次，IrDA设备中的核心部件--红外线LED不是一种十分耐用的器件。对于传输要求高、使用次数少、移动范围小、价格比较低的设备，如打印机、扫描仪、数码相机等是首选。</p>
<h2 id="zigbee">ZigBee</h2>
<p>ZigBee主要应用于短距离范围内对传输速率要求不高的设备。与蓝牙相比，ZigBee 更简单、速率更慢、功率及费用也更低。它的基本速率是250kbps，当降低到28kbps时，传输范围可以扩大到134m，并获得更高的可靠性。另外，它可与254个节点连网。可以比蓝牙更好地支持游戏、消费电子、仪器和家庭自动化应用。</p>
<p>ZigBee的技术特点如下：</p>
<ul>
<li>数据传输速率低，只有20-250kbps，专注于低传输应用。</li>
<li>功耗低，在低功耗待机模式下，两节普通5号干电池可以使用6个月以上。</li>
<li>成本低，网络容量大，每个ZigBee网络最多可支持255个设备。</li>
<li>有效范围小，在10-75m之间，具体根据实际发射功率的大小和各种不同的应用模式而定，基本上能够覆盖普通的家庭或者办公室环境。</li>
<li>工作频段灵活，使用的频段分别为2.4GHz、868MHz（欧洲）及915MHz(美国)，均为免执照频段。</li>
</ul>
<h2 id="rfid">RFID</h2>
<p>射频识别（Radio Frequency Identification,RFID）是一种非接触式的自动识别技术，其基本原理是利用射频信号及其空间耦合（电感或电磁耦合）的传输特性，实现对静止或者移动物品的自动识别。一个简单的RFID系统由阅读器（Reader）,应答器（Transponder）或电子标签（Tag）组成，其原理是由读写器发射特定频率的无线电波能量给应答器，用以驱动应答器电路，读取应答器内部的ID码。</p>
<p>RFID技术的特点如下：</p>
<ul>
<li>通过电磁耦合方式来传送识别信息，不受空间限制，可快速地进行物体跟踪和数据交换。</li>
<li>电子标签的小型化和多样化。</li>
<li>非接触式读写有很好的耐环境性。</li>
<li>可重复使用。</li>
<li>穿透性，可以很好的穿透非金属物质进行通信。</li>
<li>数据记忆容量大。</li>
<li>系统安全性。</li>
</ul>
<h2 id="nfc">NFC</h2>
<p>近场通信（Near Field Communication,NFC）是种类似RFID的短距无线通信技术标准。与RFID不同的是，NFC采用了双向的识别和连接。工作频率为13.56MHz，工作距离在20cm以内。</p>
<p>NFC最初仅仅是RFID和网络技术的合并，但现在已经发展成完整的无线连接技术。它能快速地建立无线网络，为蜂窝设备、蓝牙设备、Wi-Fi设备提供一个“虚拟连接”，使电子设备可以在短距范围内进行通信。NFC的短距离交互大大简化了整个认证识别过程，使得电子设备间的互相访问更直接、安全和清楚。</p>
<p>NFC主要特点如下：</p>
<ul>
<li>距离低，能耗低。</li>
<li>更具安全性。</li>
<li>与现有的非接触式智能卡技术相兼容。</li>
<li>传输速率低。</li>
</ul>
<h2 id="uwb">UWB</h2>
<p>超宽带（Ultra Wide Band,UWB）技术是一种无线载波通信技术，它不采用正弦滤波，而是利用纳秒级的非正弦波窄脉冲传输数据，因此其所占用的频谱范围很宽。</p>
<p>UWB技术具有系统复杂度低、发射信号功率谱密度低、对信道衰落不敏感、低截获能力、定位精度高等优点，尤其适用于室内等密集多径场所的高速无线接入，非常适用于建立一个高效的无线局域网或无线个域网（WPAN）。</p>
<h2 id="z-wave">Z-Wave</h2>
<p>Z-Wave是一种新兴的基于射频的、低成本、低功耗、高可靠，适用于网络的短距离无线通信技术。它的工作频带为868.42MHz（欧洲）- 908.42MHz(美国)，采用FSK（BFSK/GFSK）调制方式，数据传输速率为9.6kbps，信号的有效覆盖范围在室内是30m，室外可以超过100m，适用于窄带应用场合。</p>
<h2 id="-">参考</h2>
<p>《物联网与短距离无线通信技术》 董健 编著
<a href="http://book.douban.com/subject/19956231/" target="_blank">http://book.douban.com/subject/19956231/</a></p>
]]></content>
    <summary type="html"><![CDATA[<h2 id="-">短距无线通信技术</h2>
<p>什么是短距无线通信技术？到目前为止，学术界和工程界对此无严格的定义。一般来说，短距无线通信技术的主要特点是通信距离短，覆盖范围在几十米或上百米之内。无线发射器的发射功率较低，一般小于100mW。工作频率多为免付费，免申请的的全球通用工业、科学、医学频段。短距无线通信的范围很广，一般意义上，只要通信收发双方通过无线电波传输信息，并且传输距离限制在较小范围内，通常是几十米以内，就可以称之为短距无线通信。</p>
]]></summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用Automator工具DIY一个Send to Kindle功能]]></title>
    <link href="http://yoursite.com/2014/03/04/diy-send-to-kindle-with-automator/"/>
    <id>http://yoursite.com/2014/03/04/diy-send-to-kindle-with-automator/</id>
    <published>2014-03-04T14:21:22.000Z</published>
    <updated>2014-03-05T06:02:21.000Z</updated>
    <content type="html"><![CDATA[<h2 id="-">前言</h2>
<p>话说Kindle真乃看书神器也，入手Kindle Paperwhite 2 一周不到，已然看完了一本书。唯一美中不足的是传输电子书需要通过数据线，好吧，都移动互联网时代了，还是用线来传数据总是件很low的事。</p>
<a id="more"></a>

<p>这个问题Amazon官方必然是有考虑到了，于是就有了Send to Kindle这么一个软件，也有相应的Chrome/Firefox插件。不过别忘了你是在天朝这么一个奇葩地方，国内的Amazon账号与米帝账号是无法互通的。因此，对于国行版Kindle而言，前面两条路基本就被堵死了，或许会有一些hack的方法，不过鉴于折腾起来比较麻烦，还是考虑其他方式。</p>
<p>对于国内用户而说，Amazon官方提供的无线传输方式只有邮件这一种形式。在官网注册好Kindle并配置接收邮箱之后，即可通过这种方式发送自己的文档。这种方式是挺好的，无奈每次都手动发邮件实在效率太低（好吧，我承认其实就是自己太懒），于是考虑了下是否有自动化的方法。作为Mac用户，提到自动化很自然地会想到一个叫做Automator的东西。</p>
<h2 id="automator">Automator</h2>
<p>Automator是苹果公司为的Mac OS X系统开发的一款软件。只要通过点击拖拽鼠标等操作就可以将一系列动作组合成一个工作流，从而帮助你自动的（可重复的）完成一些复杂的工作。</p>
<p>它能横跨很多不同种类的程序，包括：查找器、Safari网络浏览器、iCal、地址簿或者其他的一些程序，除了官方程序，还能和一些第三方的程序一起工作，如微软的Office、Adobe公司的Photoshop或者Pixelmator等。</p>
<p>Automator实际上是一些列动作（文件重命名，找链接的图片、写邮件等等）组合在一个工作流文档里。工作流文档用来执行一系列的重复劳动，可以保存和重复执行。Unix命令行操作或者AppleScript也可以被当作一个动作在流里面执行。工作流也可以另存为一个程序，一个工作流文件，或者菜单项。</p>
<h2 id="-">思路</h2>
<p>我们先来整理下之前手动操作的流程。</p>
<p><img src="http://ww2.sinaimg.cn/large/674a21d2gw1ee43u8770tj209v03v0so.jpg" alt="操作流程"></p>
<p>对于以上流程而言，只有一个输入是来自本地硬盘文件，其他都可以通过自动化实现。</p>
<h2 id="-">实现</h2>
<p>根据上面的思路，使用Mac下原生的Mail程序，当然，需要提前配置好默认账号为Kindle管理中认可的发件人账号。</p>
<p>实现步骤如下：</p>
<ul>
<li><p>使用Automator新建一个应用程序，这种类型可以使用文件或者文件夹作为输入。</p>
</li>
<li><p>在Automator中添加新建邮件的操作，收件人是自己的kindle邮箱，主题随意。</p>
</li>
<li><p>添加附件和发送邮件操作，其中添加附件这步操作会自动从输入流中取文件数据。</p>
</li>
</ul>
<p>完成后导出，使用时将需要发送的文件拖拉到Automator程序上即可。</p>
<p>完整的实现如下图：
<img src="http://ww4.sinaimg.cn/large/674a21d2gw1ee44rrndavj20w011gwkf.jpg" alt="automator"></p>
]]></content>
    <summary type="html"><![CDATA[<h2 id="-">前言</h2>
<p>话说Kindle真乃看书神器也，入手Kindle Paperwhite 2 一周不到，已然看完了一本书。唯一美中不足的是传输电子书需要通过数据线，好吧，都移动互联网时代了，还是用线来传数据总是件很low的事。</p>
]]></summary>
    
      <category term="Automator" scheme="http://yoursite.com/tags/Automator/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[基于树莓派搭建的Tornado WebService性能测试]]></title>
    <link href="http://yoursite.com/2014/03/02/pi-performance-testing-with-tornado-and-nginx/"/>
    <id>http://yoursite.com/2014/03/02/pi-performance-testing-with-tornado-and-nginx/</id>
    <published>2014-03-02T15:27:39.000Z</published>
    <updated>2014-03-02T16:56:23.000Z</updated>
    <content type="html"><![CDATA[<h2 id="-">前言</h2>
<p>毕业设计是基于树莓派来折腾一个简易的智能家居系统，其中树莓派作为核心控制器提供服务。虽然知道对于树莓派这样的廉价玩具，在性能上并不会有着出众的表现，不过仍然挺好奇一个单核arm架构的廉价计算机性能究竟如何，于是就自己动手简单测试了下。</p>
<a id="more"></a>

<h2 id="-">测试环境</h2>
<h3 id="-">硬件</h3>
<p>树莓派B型</p>
<ul>
<li>CPU:单核 ARM1176JZF-S（ARM11系列）700MHz</li>
<li>内存:512MB</li>
</ul>
<h3 id="-">软件</h3>
<p>服务器前端放置一个Nginx来处理静态请求，动态的则转发给Tornado来处理，后端使用SQLAlchemy作为ORM，连接MySQL数据库。</p>
<p>根据Tornado官方文档，来配置了Nginx转发请求。
参考：<a href="http://www.tornadoweb.cn/documentation" target="_blank">http://www.tornadoweb.cn/documentation</a></p>
<p>主要配置点如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
</pre></td><td class="code"><pre> <span class="comment"># 针对单核处理器，仅配置一个worker进程</span>
worker_processes <span class="number">1</span>;

http {
    <span class="comment"># 转发请求到本地8080端口的Tornado服务器，同样只使用一个进程</span>
    upstream frontends {
        server <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8080</span>;
    }

    <span class="keyword">include</span> /etc/nginx/mime.types;
    default_type application/octet-stream;

    access_log /<span class="keyword">var</span>/log/nginx/access.log;

    keepalive_timeout <span class="number">65</span>;
    proxy_read_timeout <span class="number">200</span>;
    sendfile on;
    tcp_nopush on;
    tcp_nodelay on;
    gzip on;
    gzip_min_length <span class="number">1000</span>;
    gzip_proxied any;
    gzip_types text/plain text/html text/css text/xml
               application/x-javascript application/xml
               application/atom+xml text/javascript;

    proxy_next_upstream error;

    server {
        listen <span class="number">80</span>;
        
        client_max_body_size <span class="number">50</span>M;

        location ^~ /<span class="keyword">static</span>/ {
            root /<span class="keyword">var</span>/www;
            <span class="keyword">if</span> (<span class="variable">$query_string</span>) {
                expires max;
            }
        }
        location = /favicon.ico {
            rewrite (.*) /<span class="keyword">static</span>/favicon.ico;
        }
        location = /robots.txt {
            rewrite (.*) /<span class="keyword">static</span>/robots.txt;
        }

        location / {
            proxy_pass_header Server;
            proxy_set_header Host <span class="variable">$http_host</span>;
            proxy_redirect <span class="keyword">false</span>;
            proxy_set_header X-Real-IP <span class="variable">$remote_addr</span>;
            proxy_set_header X-Scheme <span class="variable">$scheme</span>;
            proxy_pass http:<span class="comment">//frontends;</span>
        }
    }
}
</pre></td></tr></table></figure>

<h3 id="-">系统架构图</h3>
<p><img src="http://ww2.sinaimg.cn/large/674a21d2gw1ee1vdc95s1j20fo0ej74s.jpg" alt="系统架构"></p>
<h2 id="-">测试方法</h2>
<p>服务端部署了一个简单登录逻辑</p>
<p>使用Siege工具进行压测，使用方法参考：
<a href="http://www.javaranger.com/archives/1168" target="_blank">http://www.javaranger.com/archives/1168</a></p>
<p>命令行请求
<code>siege -c 500 -r 1 &quot;http://192.168.1.150/service/login POST user_id=1&amp;password=123456&quot;</code></p>
<h2 id="-">测试结果</h2>
<h3 id="-">单请求</h3>
<p>针对每个用户发一次请求的情况下，基本可以保持500个用户的并发。
<img src="http://ww3.sinaimg.cn/large/674a21d2gw1ee1vnb5vukj21k50caahu.jpg" alt="单请求"></p>
<h3 id="-">多请求</h3>
<p>考虑到实际情况，可能有一次请求不成功然后发多次请求的情况，以5次为例。
实际测试发现325个用户，每个用户5次请求，即总1625次请求下，基本达到性能极限，请求成功率99.88%，超过这个数字则产生大量超时请求。
<img src="http://ww1.sinaimg.cn/large/674a21d2gw1ee1vqvdwc7j21jb0c6aha.jpg" alt="多请求"></p>
<h3 id="-">总结</h3>
<p>虽然限于本身硬件问题，树莓派的并发性能不是很好，但作为一个的家用型智能家居自动化核心控制器应当足够用了。</p>
]]></content>
    <summary type="html"><![CDATA[<h2 id="-">前言</h2>
<p>毕业设计是基于树莓派来折腾一个简易的智能家居系统，其中树莓派作为核心控制器提供服务。虽然知道对于树莓派这样的廉价玩具，在性能上并不会有着出众的表现，不过仍然挺好奇一个单核arm架构的廉价计算机性能究竟如何，于是就自己动手简单测试了下。</p>
]]></summary>
    
      <category term="树莓派" scheme="http://yoursite.com/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS开发基础知识整理]]></title>
    <link href="http://yoursite.com/2014/02/25/basic-knowledge-of-ios-development/"/>
    <id>http://yoursite.com/2014/02/25/basic-knowledge-of-ios-development/</id>
    <published>2014-02-25T08:18:24.000Z</published>
    <updated>2014-02-25T11:02:15.000Z</updated>
    <content type="html"><![CDATA[<h2 id="block">Block</h2>
<p>Block本质上就是一个带有局部变量的匿名函数，它于iOS4之后引入，基于C语言的指针和函数指针实现。</p>
<a id="more"></a>

<figure class="highlight [objc]"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>Block语法：
^(<span class="keyword">int</span> <span class="keyword">event</span>){
    <span class="comment">//doSomething</span>
}
</pre></td></tr></table></figure>

<h2 id="-arc-">自动引用计数（ARC）</h2>
<p>“在Objective-C采用Automatic Reference Counting (ARC)机制，让编译器来进行内存管理。在新一代Apple LLVM编译器中设置ARC为有效状态，就无需再次键入retain或者release代码，这在降低程序崩溃、内存泄漏等风险的同时，很大程度上减少了开发程序的工作量。编译器完全清楚目标对象，并能够立刻释放那些不再被使用的对象。如此一来，应用程序将具有可预测性，且能流畅运行，速度也将大幅提升。” -- 苹果关于ARC机制的官方说明</p>
<p>引用计数式内存管理的思考方式：</p>
<ul>
<li>自己生成的对象，自己持有。</li>
<li>非自己生成的对象，自己也能持有。</li>
<li>不再需要自己持有的对象可以释放。</li>
<li>非自己持有的对象不能释放。</li>
</ul>
<p>上述思考方式同时适用于ARC和非ARC下，对于ARC的情况下，有以下4个所有权修饰符：</p>
<table>
<thead>
<tr>
<th>修饰符</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>__strong</td>
<td>强引用</td>
</tr>
<tr>
<td>__weak</td>
<td>弱引用</td>
</tr>
<tr>
<td>__unsafe_unretained</td>
<td>不安全不持有</td>
</tr>
<tr>
<td>__autoreleasing</td>
<td>自动释放</td>
</tr>
</tbody>
</table>
<p>使用ARC要遵守以下一些规则：</p>
<ul>
<li>不能使用retain/release/retainCount/autorelease</li>
<li>不能使用NSAllocateObject/NSDeallocateObject</li>
<li>需要遵守内存管理的方法命名规则</li>
<li>不要显式地调用dealloc</li>
<li>使用@autoreleasepool替代NSAutoreleasePool</li>
<li>不能使用区域（NSZone）</li>
<li>对象型变量不能作为C语言结构体(struct/union)的成员</li>
<li>显式转换&quot;id&quot;和&quot;void *&quot;</li>
</ul>
<p>一个经典案例--Block中循环引用导致内存泄漏：</p>
<figure class="highlight [objc]"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="keyword">self</span>.block = ^{
    [<span class="keyword">self</span> doSomething];
};
</pre></td></tr></table></figure>

<p>以上这段代码由于block在拷贝到堆上，会自动retain其引用的外部变量，造成两个对象互相强引用，导致我们俗称的循环引用出现。</p>
<p>因此，对于一般在block需要引用对象自身的情况，一般采用<strong>unsafe_unretained或者</strong>weak创建，如下：</p>
<figure class="highlight [objc]"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>__block __unsafe_unretained YourObject* weakself = <span class="keyword">self</span>;
<span class="keyword">self</span>.<span class="keyword">block</span> = ^<span class="comment">{
    [weakself doSomething];
}</span>;
</pre></td></tr></table></figure>

<h2 id="grand-central-dispatch-gcd-">Grand Central Dispatch(GCD)</h2>
<p>&quot;Grand Central Dispatch(GCD)是异步执行任务的技术之一。将应用程序中记述线程管理用的代码在系统级别实现。开发者只需要定义想要执行的任务，并追加到适当的Dispatch Queue中，GCD就能生成必要的线程并执行计划任务。由于线程管理是作为系统的一部分来实现的，因此可以统一管理，比起普通的线程更有效率。&quot; -- 苹果关于GCD机制的官方说明</p>
<p>一个GCD使用的例子：</p>
<figure class="highlight [objc]"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre><span class="built_in">dispatch_async</span>(queue,^{
	
    <span class="comment">//doSomething with long time processing</span>
		
    <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(),^{
		
        <span class="comment">//process main thread with the above result</span>
        <span class="comment">//e.g. update the user interface</span>
    });
});
</pre></td></tr></table></figure>

<p>Dispatch Queue本质上是执行处理的等待队列，通过上述的dispatch_async 函数将需要异步执行的处理添加到队列中。</p>
<p>Dispatch Queue种类：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>Dispatch Queue种类</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Main Dispatch Queue</td>
<td>Serial Dispatch Queue</td>
<td>主线程执行</td>
</tr>
<tr>
<td>Global Dispatch Queue(High Priority)</td>
<td>Concurrent Dispatch Queue</td>
<td>最高优先级</td>
</tr>
<tr>
<td>Global Dispatch Queue(Default Priority)</td>
<td>Concurrent Dispatch Queue</td>
<td>默认优先级</td>
</tr>
<tr>
<td>Global Dispatch Queue(Low Priority)</td>
<td>Concurrent Dispatch Queue</td>
<td>低优先级</td>
</tr>
<tr>
<td>Global Dispatch Queue(Background Priority)</td>
<td>Concurrent Dispatch Queue</td>
<td>后台优先级</td>
</tr>
</tbody>
</table>
<p>其中Serial Dispatch Queue等待现在执行中的处理结束，Concurrent Dispatch Queue则不等待，即前者是同步执行的，会堵塞，后者则是异步执行。</p>
<p>参考：
《Objective-C高级编程-iOS与OS X多线程和内存管理》 Kazuki Sakamoto &amp; Tomonhiko Furumoto 著</p>
<h2 id="-observer-ios-">观察者模式（Observer）与iOS中的消息通信机制</h2>
<p>消息中心 NSNotificationCenter:
消息中心实际上是在程序内部提供了消息广播机制，它基于观察者模式实现，将接收到的消息转发给注册过的相应观察者对象。</p>
<p><img src="http://ww3.sinaimg.cn/large/674a21d2gw1edvt7segebj20au07cwep.jpg" alt="消息中心"></p>
<p>使用示例：</p>
<p>将当前对象设为观察者，并发送消息</p>
<figure class="highlight [objc]"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="built_in">NSNotificationCenter</span> *center = [<span class="built_in">NSNotificationCenter</span> defaultCenter];

<span class="comment">//register observer</span>
[center addObserver:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(GetMessage:) name:@<span class="string">"message"</span> object:<span class="literal">nil</span>];
 
<span class="comment">//send message</span>
[center postNotificationName:@<span class="string">"message"</span> object:@<span class="string">"content"</span>];
</pre></td></tr></table></figure>

<p>消息发出后，调用GetMessage方法</p>
<figure class="highlight [objc]"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>-(<span class="keyword">void</span>) GetMessage:(<span class="built_in">NSNotification</span> *) notificaion{
    
    <span class="built_in">NSString</span> *message = [notificaion object];
    <span class="built_in">NSLog</span>(@<span class="string">"%@"</span>,message);
}
</pre></td></tr></table></figure>

]]></content>
    <summary type="html"><![CDATA[<h2 id="block">Block</h2>
<p>Block本质上就是一个带有局部变量的匿名函数，它于iOS4之后引入，基于C语言的指针和函数指针实现。</p>
]]></summary>
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[一种物联网普适计算的DIY方法：智能闹钟 (译)]]></title>
    <link href="http://yoursite.com/2014/02/20/diy-smart-alarm-clock-with-raspberry-pi/"/>
    <id>http://yoursite.com/2014/02/20/diy-smart-alarm-clock-with-raspberry-pi/</id>
    <published>2014-02-20T03:15:13.000Z</published>
    <updated>2014-02-21T07:40:12.000Z</updated>
    <content type="html"><![CDATA[<h2 id="-">原文</h2>
<p><a href="http://www.deepdyve.com/lp/institute-of-electrical-and-electronics-engineers/a-diy-approach-to-pervasive-computing-for-the-internet-of-things-a-KOj52wCzTu" target="_blank">http://www.deepdyve.com/lp/institute-of-electrical-and-electronics-engineers/a-diy-approach-to-pervasive-computing-for-the-internet-of-things-a-KOj52wCzTu</a></p>
<h2 id="-">摘要</h2>
<p>本文通过一个智能闹钟的例子，探讨了物联网（IoT）DIY社区如何使用最新开发的低成本系统级芯片（SoC）开发板来促进智能对象的创新进程。这个闹钟将使用本地的温度传感器读数结合现有的交通和天气Web服务，提供给用
户合适的提醒时间。并且包括了一个对现今可用的物联网部件和最先进的提
供增强功能的闹钟的简要回顾。提供一种对闹钟软硬件部件描述和判断。CPU
和内存资源测试表明了SoC设备在智能闹钟下的适用性。用户反馈则为闹钟功
能提供了进一步发展的建议。</p>
<a id="more"></a>

<h2 id="-">关键词</h2>
<p>物联网，智能闹钟，树莓派，系统级芯片，DIY，XBEE，智能物体</p>
<h2 id="-">导言</h2>
<p>除了经济利益的驱使之外，人类对于DIY有着强烈的驱动力，将DIY作为创造力，控制力，多元化，社会性的过度消费主义和全球化的出口，甚至仅仅是简单地想要自己实现[1]。最近的DIY电子设备趋势给在物联网（早期被称为嵌入式网络设备[2]）和智能城市、智能家居中进行大量创新提供了工具。</p>
<p>智能物体是物联网的关键组件，它定义了物体的扩展能力，比如逻辑处理，信息存储，传感，现实世界的事件驱动和网络通信，并通过小型计算机使之成为可能。智能物体可以在彼此间通信和互动，以及与环境，互联网和人类通信[3]。现有的一个智能物体的例子是Karotz[4]，它是一个基于互联网的语音激活智能兔子，它所消耗的feed是从一个Web服务中选择，并且大声的读取feed。Karotz还集成了RFID传感器，用来检测可用的RFID标签的存在。</p>
<p>本文侧重于通过智能闹钟这样一个形式去评估对于在智能物体的创新中最先进的SoC技术的使用。该装置将具备将本地的温度传感器读数结合交通和天气Web服务数据，来自动调整提醒时间的能力，以便于终端用户在预定的时间到达一个位置。这种装置可以减轻旅途中规划的负担，同时减少浪费在交通拥挤的时间，准时到达他们的目的地。</p>
<h2 id="1-">1.智能对象创新的可用技术</h2>
<h4 id="-soc-">微控制器和系统级芯片（SoC）板</h4>
<p>低成本且低功率的微控制器和SoC板的出现，使得可以使用高级语言，比如C#或者Python进行编程，这有助于物联网智能对象的创新[5]。Arduino（使用Wiring编程），Gadgeteer和Netduino（都使用.Net框架编程）都是微控板的例子。一个SoC板子则相当于一个跑了操作系统的PC。SoC板子的例子是树莓派，它使用自有版本的Linux操作系统，称之为Raspbian[6]。Python是Raspbian系统下预装的默认编程语言，选择它是由于其简单性和解释性语言特征，这意味着可以无需编译直接执行代码[6]。一个SoC板子提供的主要好处是，它能在一个适于集成到智能物体的小设备中跑多个进程。</p>
<h4 id="-">智能对象和他们与现实世界的交互</h4>
<p>智能物体需要有能从他们当前环境收集数据，并触发现实世界事件的能力。这一般通过电子传感器和执行器来实现。现在对于DIY爱好者而言，已经有大量的低成本模拟和数字电子传感器可用，包括光，颜色，弯曲，力，运动，压力，温度，湿度，脉冲，加速度和倾斜传感器等等[7]。执行器可以用于开关发光二极管，发动机，音频输出设备和电子继电器等等。智能物体另一个主要的功能是能够通过本地网络或者互联网传输和接收数据。有很多网络产品被设计成用于低功耗协议，比如6LoWPAN和ZigBee，它们越来越流行用于创造个人无线传感器网络。Digi International公司的XBEE和思科的XRF无线电台是这类解决方案的例子。低功耗使得这些无线电设备很适用于传输和接收传感器小数据包和驱动数据（不同于标准化的Wi-Fi发送器，它被设计用于传输大型的多媒体文件数据）</p>
<h2 id="2-">2.回顾现行最先进的闹钟</h2>
<p>在写这篇论文的时候，市售的智能闹钟没有基于天气和交通条件动态调整提醒时间的功能。一些商业的闹钟，比如La Crosse WE-8115U-S 原子数字时钟[8]，具有将室内外温湿度读数显示在时钟LCD上的功能，但是却没有对这些读数进行逻辑处理。</p>
<h4 id="-">智能闹钟原型</h4>
<p>动态可编程闹钟（DPAC）是一种自我设定的闹钟，它由波士顿东北大学的学生MA设计，使用谷歌日历上的日程去设置提醒时间，并基于现行交通、天气状况进行自动调整[9].Web服务请求和闹钟逻辑通过供给时钟的提醒时间外部Web服务来运行。</p>
<p>Rise闹钟[10]是另外一个原型，它利用交通状况去计算最佳的提醒时间。它并不把天气数据存在账户内，并且需要通过电话机插座连接到互联网。</p>
<h4 id="-">智能手机的闹钟程序</h4>
<p>Smart Alarm Clock Pro++ 是一个智能闹钟程序的例子，它使用天气状态去自动调整提醒时间。程序也添加了RSS功能和天气Feeds。这种应用逻辑决定了提醒时间仅限于根据天气预报，而不把交通状况纳入考虑范围内。</p>
<p>虽然通过智能手机下载一个智能闹钟应用有着无需初始硬件支出的好处，手机需要一个合适的底座和充足电源供应去显示专用的闹钟。</p>
<h2 id="3-">3.闹钟功能</h2>
<p>智能闹钟的一个主要特征是运行包含当地传感器数据和网络服务的内部逻辑，并根据预定位置和期望的时间，来确定对于终端用户最佳的提醒时间。提醒时间的调整，依赖于交通状况和天气预报数据的精确性。本地天气传感器的读数可以用于进一步的调整提醒时间，以便驾驶员有足够时间去对他们的交通工具除雪。本地的天气传感器可以用于根据用户的当地环境提高读数精确度。智能闹钟的其它特征包括：</p>
<ul>
<li>通过网络服务来滚动显示新闻标题</li>
<li>访问互联网电台</li>
<li>为预定的路线显示当前的交通状况</li>
<li>通过网络服务显示当地的天气</li>
<li>存放自定义Web页面，以便使用一个局域网内的电脑作为闹钟</li>
</ul>
<h2 id="4-">4.闹钟的体系架构</h2>
<h4 id="-">闹钟的硬件</h4>
<p>根据第3节中的信息，智能闹钟可以被用于执行逻辑函数，因此一个SoC板子是必要的。我们选择了现成的树莓派，它有一个活跃的开发者社区分享项目和技术指引[11]。由于树莓派被限制于通过它所连接的网络获取时间信息，额外添加一个实时时钟（RTC）模块，可以确保在网络不可用的情况下有正确的时间读数。</p>
<p>本地传感器和树莓派之间的温湿度读数使用XBEE无线发送器来提供数据通信。XBEE发送器提供了低功耗的数据传输功能，并拥有文档完善的API[12]。一个20x4字符的（HD44780）液晶显示器[13]提供了可视化的闹钟数据显示。对于长度超过20个文本的字符串可以滚动显示。控制板用来提供闹钟的用户输入界面，它有5个输入按钮，由8位端口拓展器芯片（MCP23008）[14]连接到树莓派的I2C接口组成。树莓派的3.5毫米音频输出插孔连接了一个合适的放大器解决方案和扬声器作为闹钟的音频输出。</p>
<p><img src="http://ww3.sinaimg.cn/large/674a21d2gw1edq5udplnlj20ty0iejuo.jpg" alt="图1-树莓派智能闹钟和本地温度传感器接线图"></p>
<h4 id="-">本地温湿度传感器的硬件</h4>
<p>RHT03数字式温湿度传感器提供了高精度且可靠的读数[15]。Netduino Plus 2[16]微控制器板用于处理传感器的读数以及通过UART端口传输它们到无线XBEE模块。如果希望更省电，可以使用一个更小的控制器接口代替Netduino Plus 2，这样可以使用电池给传感器供电。</p>
<h4 id="-web-">软件和Web服务</h4>
<p>由于Raspbian系统预装了Python语言环境，以及它对于GPIO引脚驱动的原生支持，闹钟软件使用Python来实现。Netduino Plus 2使用.Net框架编写，并且使用C#语言去收集和传输本地传感器数据。</p>
<p>Bing地图REST服务[17]提供了一个简单的RESTful接口请求道路沿线交通数据，因此被用做提醒时间计算的Web服务。天气数据收集则是通过英国气象局[18]以简单格式提供的DataPoint API。XBEE通信是通过XBEE API来进行错误校验以确保传感器数据传输的正确性。使用音乐播放器守护程序（MPD）来建立网络收音机，并通过MPC客户端[19]来访问。</p>
<h4 id="-">闹钟软件的实现</h4>
<p><img src="http://ww4.sinaimg.cn/large/674a21d2gw1edq6e23g7oj20uw0isjuw.jpg" alt="图2-软件体系结构框架图"></p>
<h2 id="5-">5.评价</h2>
<p>初步测试表明树莓派可以干练地运行智能闹钟应用，同时处理Web服务，本地传感器数据请求，LCD输出，控制板输入请求和自有的web服务器上运行的设置界面。根据Linux进程监控，在标准操作情况下闹钟最高会占用25-27%的CPU和2.4%的内存。当同时激活了网络电台，需要额外占用12%的CPU和2.5%的内存（根据配置变化最高会达到25%）。这明显给未来添加其他服务预留了内存和处理能力。</p>
<p>阿格利亚罗斯金大学的4个信息学理学硕士进行了用户试验，获取到了闹钟功能反馈。在独立评估LCD模块和控制板的可用性之前，我们向每个学生提供了一份闹钟的概要。</p>
<p><img src="http://ww4.sinaimg.cn/large/674a21d2gw1edq7vmp2b1j20uu0gyacu.jpg" alt="图3-在20x4液晶显示模块上的闹钟屏幕布局"></p>
<p>用户反馈了如下的建议：</p>
<ul>
<li>使用更大的屏幕提高清晰度和添加新的服务</li>
<li>连接谷歌日历接口以便在提醒日之前一天显示邀约。</li>
<li>提供一个更直观的方式配置提醒设置，比如更大的屏幕，语音命令或者配套的智能手机应用。</li>
<li>将程序移植成为一个智能手机应用，以便在不在家的情况下使用。</li>
<li>添加社交媒体Feeds,比如Facebook和Twitter。</li>
</ul>
<h2 id="-">结论和未来的工作</h2>
<p>这项工作表明，出于物联网创新的目的，智能物体中集成树莓派这类SoC板子，可以极大地提高这些对象的本地处理能力，并且不需要常见标准PC那样的电能耗费。小型的SoC板子使得智能物体可以被用在那些标准PC不适用的场景下。由于树莓派的计算能力仅相当于300MHz的奔腾ⅡPC[20],在闹钟的设计和研发过程中，数据传输是有限制的（尽可能）使用轻量级的标准，比如JSON。数据存储也限制于本地文件存储而不是专业的数据库。</p>
<p>虽然Bing地图服务提供了一个简单的RESTful接口用于请求沿线的交通数据，但使用此服务有一个限制是要从服务所提供的描述来计算延迟。谷歌地图结合了生活和历史交通数据有效地计算出了延迟时间[21]，虽然在写这篇论文的时候，通过谷歌地图API获取这些信息需要有商业许可。英国高速公路管理局在data.gov.uk网页上通过XML格式发布了实时的交通数据信息。[22]这是一个综合的未经加工的实时数据信息，但是需要翻译成地理路线，这超过了本项目范围目标之外。</p>
<p>在当前的实现中，本地温湿度传感器是直接通过XBee无线模块直接传输数据的。传感器的读数可以发布到互联网上的服务比如Xively（以前被称为Cosm and Pachube）[23],它提供了API以供其它服务去使用读数。考虑到无线传感器的数量有限，也可以通过闹钟的WiFi适配器直接传输传感器数据到互联网。使用闹钟去发布数据占用很少的硬件资源开销，但是添加传感器可能会导致闹钟性能的影响。普适计算的一个基本概念是通过传感器和计算能力与环境融为一体，从而利于人类居住者[24],因此，智能物体开始和很多其它的本地网络节点（其它智能物体与本地传感器/执行器）交互，其对于计算开销的要求也相应地提高。一个解决方案是将所有的节点发送到本地的专用智能网关，它可以获取内部和外部（互联网）的节点数据。其中一个现在正在开发的这类网关是思科的EVA Alpha板子，它适用于树莓派[25]，它的特点是将多个无线传感器网络协议集成到一个单板上。树莓派作为本地网络和互联网之间的网关。该模型的优势包括通过限制直接联网数量增加了网络的安全性，减少了节点的资源过载，并且让网络协议与自动化节点发现和订阅[26]功能两者间能更好的协同工作。</p>
<p>所有用于创建闹钟的组件在DIY社区里面都有着广泛的文档记录，并且可以自由获取，这使得物联网领域的创新潜力大大提升。对于传统的产品设计而言，最终用户是预定义解决方案的使用人，相比之下，产品创新DIY方法是实现更加个性化和多终端产品的催化剂。</p>
<h2 id="-">参考资料</h2>
<ol>
<li>Marc Roelands, Laurence Claeys, Marc Godon, Marjan Geerts, Mohamed Ali Feki, Lieven Trappeniers, Enabling the Masses to Become Creative in Smart Spaces, Architecting the Internet of Things, Springer-Verlag, Berlin Heidelberg (2011), 38, 42-43, 40.</li>
<li>Chin J, Callaghan V., Embedded-Internet Devices: A Means of Realising the Pervasive Computing Vision, Proceedings of the IADIS International Conference WWW/Internet 2003, ICWI 2003, Algarve Portugal, 2003</li>
<li>Irena Pletikosa Cvijikj, Florian Michahelles, The Toolkit Approach for End-user Participation in the Internet of Things, Architecting the Internet of Things, Springer-Verlag, Berlin Heidelberg (2011), 66.</li>
<li>Karotz: <a href="http://store.karotz.com/en_US/" target="_blank">http://store.karotz.com/en_US/</a></li>
<li>Cuno Pfister, Getting Started with the Internet of Things, O’Reilly Media Inc., Sebastopol, CA, USA,
2011</li>
<li>Matt Richardson and Shawn Wallace, Getting Started with Raspberry Pi, O’Reilly Media Inc.,
Sebastopol, CA, USA, 2013</li>
<li>Robert Faludi, Building Wireless Sensor Networks, O’Reilly Media Inc., Sebastopol, CA, USA, 2011 </li>
<li>La Crosse Technology: <a href="http://wwwlacrossetechnology.com/308-145/" target="_blank">http://wwwlacrossetechnology.com/308-145/</a></li>
<li>Eric Gaertner, DPAC – The Dynamically Programmable Alarm Clock: <a href="http://egaertner.com/dpac/" target="_blank">http://egaertner.com/dpac/</a></li>
<li>BBC News, Smart alarm clock lets you lie in: <a href="http://news.bbc.co.uk/1/hi/technology/2269144.stm" target="_blank">http://news.bbc.co.uk/1/hi/technology/2269144.stm</a></li>
<li>Raspberry Pi Forum: <a href="http://www.raspberrypi.org/phpBB3/" target="_blank">http://www.raspberrypi.org/phpBB3/</a></li>
<li>Digi International: <a href="http://ftp1.digi.com/support/documentation/90000982_B.pdf" target="_blank">http://ftp1.digi.com/support/documentation/90000982_B.pdf</a></li>
<li>Futulec MCP23008 Datasheet: <a href="https://www.futurlec.com/SFMicrochip/MCP23008.shtml" target="_blank">https://www.futurlec.com/SFMicrochip/MCP23008.shtml</a></li>
<li>HobbyTronics: <a href="http://www.hobbytronics.co.uk/lcd-20-4-backlight-blue" target="_blank">http://www.hobbytronics.co.uk/lcd-20-4-backlight-blue</a></li>
<li>Maxdetect: <a href="http://dlnmh9ip6v2uc.cloudfront.net/datasheets/Sensors/Weather/RHT03.pdf" target="_blank">http://dlnmh9ip6v2uc.cloudfront.net/datasheets/Sensors/Weather/RHT03.pdf</a></li>
<li>Netduino: <a href="http://netduino.com/netduinoplus2/specs.htm" target="_blank">http://netduino.com/netduinoplus2/specs.htm</a></li>
<li>MSDN Bing Maps REST Services: <a href="http://msdn.microsoft.com/en-us/library/ff701713.aspx" target="_blank">http://msdn.microsoft.com/en-us/library/ff701713.aspx</a></li>
<li>Met Office DataPoint: <a href="http://www.metoffice.gov.uk/datapoint" target="_blank">http://www.metoffice.gov.uk/datapoint</a></li>
<li>MPC Linux man page: <a href="http://linux.die.net/man/1/mpc" target="_blank">http://linux.die.net/man/1/mpc</a></li>
<li>Raspberry Pi FAQs: <a href="http://www.raspberrypi.org/faqs" target="_blank">http://www.raspberrypi.org/faqs</a></li>
<li>Google Maps: <a href="http://support.google.com/maps/bin/answer.py?hl=en&amp;answer=2549020" target="_blank">http://support.google.com/maps/bin/answer.py?hl=en&amp;answer=2549020</a></li>
<li>Data.gov.uk: <a href="http://data.gov.uk/dataset/live-traffic-information-from-the-highways-agency-road-
network">http://data.gov.uk/dataset/live-traffic-information-from-the-highways-agency-road-
network</a></li>
<li>Xively.com: <a href="https://xively.com/" target="_blank">https://xively.com/</a></li>
<li>Satyanarayanan, M, Pervasive computing: vision and challenges, Personal Communications, vol. 8,
Issue 4 (2001), 10-17</li>
<li>Kickstarter, EVE Alpha - Raspberry Pi wireless development hardware:
<a href="http://www.kickstarter.com/projects/ciseco/eve-alpha-raspberry-pi-wireless-development-hardwa" target="_blank">http://www.kickstarter.com/projects/ciseco/eve-alpha-raspberry-pi-wireless-development-hardwa</a></li>
<li>Tools for the open source Internet of things: <a href="http://iot-toolkit.com/" target="_blank">http://iot-toolkit.com/</a></li>
</ol>
]]></content>
    <summary type="html"><![CDATA[<h2 id="-">原文</h2>
<p><a href="http://www.deepdyve.com/lp/institute-of-electrical-and-electronics-engineers/a-diy-approach-to-pervasive-computing-for-the-internet-of-things-a-KOj52wCzTu" target="_blank">http://www.deepdyve.com/lp/institute-of-electrical-and-electronics-engineers/a-diy-approach-to-pervasive-computing-for-the-internet-of-things-a-KOj52wCzTu</a></p>
<h2 id="-">摘要</h2>
<p>本文通过一个智能闹钟的例子，探讨了物联网（IoT）DIY社区如何使用最新开发的低成本系统级芯片（SoC）开发板来促进智能对象的创新进程。这个闹钟将使用本地的温度传感器读数结合现有的交通和天气Web服务，提供给用
户合适的提醒时间。并且包括了一个对现今可用的物联网部件和最先进的提
供增强功能的闹钟的简要回顾。提供一种对闹钟软硬件部件描述和判断。CPU
和内存资源测试表明了SoC设备在智能闹钟下的适用性。用户反馈则为闹钟功
能提供了进一步发展的建议。</p>
]]></summary>
    
      <category term="译文" scheme="http://yoursite.com/tags/%E8%AF%91%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[基于树莓派DIY家居自动化 (译)]]></title>
    <link href="http://yoursite.com/2014/02/19/home-automation-with-raspberry-pi/"/>
    <id>http://yoursite.com/2014/02/19/home-automation-with-raspberry-pi/</id>
    <published>2014-02-19T06:37:31.000Z</published>
    <updated>2014-02-19T14:36:35.000Z</updated>
    <content type="html"><![CDATA[<h2 id="-">原文</h2>
<ul>
<li><a href="http://electronician.hubpages.com/hub/DIY-Home-Automation-with-Raspberry-Pi" target="_blank">http://electronician.hubpages.com/hub/DIY-Home-Automation-with-Raspberry-Pi</a></li>
<li><a href="http://electronician.hubpages.com/hub/Home-Automation-Sensors" target="_blank">http://electronician.hubpages.com/hub/Home-Automation-Sensors</a>
（有少量删减与整合）</li>
</ul>
<h2 id="-">通过树莓派使你的家庭智能化</h2>
<p>树莓派是一个廉价的电路板，又称微控制器。它其实是一个在单片机上的小型电脑，最初设计出来是出于兴趣以及帮助学生学习电子和编程。和常见的电脑比较，它非常节能，这意味着它可以一直处于打开状态而不会耗费多少电能，并且它能够很容易地被连接到各种外设和电路板上。</p>
<a id="more"></a>

<p>以上这些特点使得用树莓派DIY家居自动化是一个理想的选择。它可以被用于控制你的电灯，家电，安防设备，以及网络娱乐设备等等。有很多的由业余爱好者和DIY爱好者组成的网络社区广泛使用树莓派进行巧妙的项目，并且有一些的高质量开源项目你可以用来上手。</p>
<p>本文将要向你介绍一些最好的资源，开源软件项目，以及其他配件或外设，你可以用它们来开始制作自己的智能家居系统。我也会着重介绍一些其他人实现并分享在网上的令人激动的项目，以便给你一些灵感，另外提供一些其他资源的网址供参考。</p>
<h2 id="-">无线家庭自动化</h2>
<p><img src="http://ww2.sinaimg.cn/large/674a21d2gw1edooaf35a6j207804w3yl.jpg" alt="无线家庭自动化"></p>
<p>Z-Wave是一种流行的家居自动化技术，可以被用于无线控制很多家用电器和电子设备。你可以通过手机App使用它去控制你的照明或暖气,去设置计划事件或场景，提高家庭安全以及其它更多的应用。</p>
<p>控制器使用了Z-Wave无线信号去和安装在你家里的设备通信，通常你可以通过一个App去控制你的系统。由于它的安装简单，不需要太多技术知识，因而在DIY爱好者中很流行，当然，对于拥有更多进阶知识的爱好者而言，它也能被黑掉并且修改。</p>
<h4 id="-">技术特征</h4>
<p>Z-Wave技术一个最重要技术特征是它采用一种叫做“多跳网络”。多跳网络拓扑意味着每个通信都广播到所有在范围内的设备，然后每个设备作为一个“转发器”，传递信息给所有的邻居。</p>
<p>多跳网络的使用具有两大优势。首先，它提高了可靠性。例如，要在客厅的控制器和楼上卧室的暖气片之间发送消息，可能同时有多条路径可以选择，这意味着在传输中不大可能丢失或者受到干扰。再者，它可以扩大范围。如果在控制器和受控设备距离比较远的情况下，大多数系统需要使用专门的转发器。由于在Z-Wave网络中每个设备相当于一个转发器，就不需要专门的转发器，只需要两者之间有另一个设备（比如楼梯灯）。</p>
<p>和很多系统一样，Z-Wave还支持双向设备通信，以便于设备可以将他们自己的状态反馈给控制器。</p>
<h4 id="-">其他技术规范</h4>
<ul>
<li>使用低功率的无线电频率（RF）通信。</li>
<li>工作在1GHz频带。这意味着它不受Wi-Fi，蓝牙或者其它流行的无线系统干扰</li>
<li>支持数据传输速率可达100kbps，并具有很强的AES128加密</li>
<li>支持多通道操作</li>
<li>基于IPv6</li>
<li>完全的向后兼容。这意味着新产品能很好的和旧产品一起工作</li>
<li>适用于智能能源协议比如OpenADR和SEP1.1</li>
</ul>
<h2 id="-diy-z-wave-">建立你自己DIY的Z-Wave家居自动化控制器</h2>
<p>Z-Wave是最流行的家居自动化协议之一。协议是便于一些用于电子设备互相通讯的规则，因此它们可以很容易地组合以创建设备网络。这意味着有很多产品，比如传感器，照明开关，调光器，恒温器，散热器阀门执行器，报警器等等都可以很轻松地被应用于Z-Wave智能家居系统中。</p>
<p>Z-Wave产品很容易安装到自己家里面，因此它们在DIY爱好者之中很流行。但是大多数人还是会购买一个现成的控制器。控制器是一个电子盒或者迷你计算机，它是你智能家居系统的“大脑”，通过任意的传感器或者开关作为输入，并且通常需要一个手机App,用来转化成命令去控制你的电器系统和电子设备。</p>
<p>如果你想要一个更廉价并且更有趣的选项，你可以采用树莓派加上U盘以及一些开源软件，去创建属于自己的控制器。虽然我不会将这描述为一个简单的项目，但你完成这些并不要求你是一个电子专家。一个正常智商并且专注的初学者就可以完成。</p>
<p>Z-Stick是一个非常好用的工具，它能讲将任何电脑变成一个Z-Wave家居自动化控制器。它很便宜，并且采用的是自供电的USB加密狗形式。Z-Stick能够识别Z-Wave设备，并将他们添加到你的网络中，然后作为一个翻译和通信设备，桥接你的计算机和家居自动化网络。如果你愿意，你可以使用这个将老电脑变成一个控制器，不过个人觉得这并不是一个好主意。首先，普通PC一直开启消耗的电能比较大。其次，旧电脑可能存在可靠性问题，而新电脑则比直接买一个现成的控制器更昂贵。</p>
<p>我们更感兴趣的是使用树莓派，并且已经有一个非常好的产品叫做Razberry。Razberry是一种树莓派的扩展板，它很容易被连接到Pi上，当你配合Z-Stick使用的时候，你已经有了全套的关联设备，包括智能手机应用。</p>
<p>除了硬件，Razberry板自带了一些优秀的开源软件，你可以用于自定义你的核心内容。它自带了一个示例程序，你可以通过很少的设置,通过安卓或者苹果手机去控制你的系统。这个程序是用Javascript编写的，这是最流行的编程语言之一，同时也被认为是初学者友好的。这使得它很容易让任何人通过示例应用程序自定义，甚至可以从头开始构建自己的。后端是用Python编写的。</p>
<p>硬件设置并不难，这意味着大部分人能够在短时间内没有太多困难的去完成一个控制器。</p>
<h2 id="-">用于家居自动化的传感器</h2>
<h4 id="-">运动和占用传感器</h4>
<p>运动检测器是家庭自动化系统最流行的传感器之一。它们常常被用于多种用途，比如在家里没人时检测到运动，会触发防盗报警器，或者当你进入或者离开房间时自动开关灯。</p>
<p>最常见运动检测器是“被动式红外传感器”，或者叫做PIR。它的工作原理是通过检测其在视野范围内的红外辐射变化。选购PIR时有效范围是非常重要的，虽然大多数PIR能够轻松地覆盖一个房间，对于大房间，特别是开放式设计的建筑物可能需要一个以上。</p>
<p>占有或者存在检测器的基本技术和常见的运动传感器技术相同，但是具有更高的分辨率。你可以很便宜地购买到PIR，它们对于很多应用程序都十分有用，比如，防盗报警或者控制楼道灯。但是如果你需要一个随时检测客厅是否被占用的系统，比如，控制光照自动照明和供暖，廉价的产品是不足够的。因为他们需要运动去触发，如果你在沙发上读书，传感器可能会错误的发送一个信号说房间是空的。存在或者占用检测器能够确定一个人是否在房间，仅仅通过他们的呼吸。</p>
<p>提示：如果你有宠物，那么你最好找一个灵敏度可调的产品。以便于你手动找到合理的平衡，而不是每次你的猫走过去都会触发。</p>
<h4 id="-">光传感器</h4>
<p>光传感器又被称为光敏二极管。它用来监测环境光水平，并且向你的家具自动化控制器报告。它通常和运动或存在传感器一起使用，以便在有人进入房间时，并在必要时，打开灯的开关。它们也被用来确保安全灯只在天黑后打开，或者在黄昏时将室外灯自动打开。如果你在室外使用光传感器，你要确保同时购买一个合适的防水外壳。</p>
<h4 id="-">温湿度传感器</h4>
<p>温湿度传感器经常被用于集成到恒温器单元或者暖气阀门，但是有些时候你可能需要安装为一个独立的温度计。小的温度传感器可以很容易地嵌入到墙中，这可以避免在墙上或者天花板上放更多的难看的盒子。</p>
<p>结合一个湿度传感器使用时，它们可以用来自动控制空调或者加湿器，甚至在房间变得太闷热时自动打开窗户。</p>
<p>防水的温度传感器可以用于室外，例如，你可以在你出门前检查你的庭院加热器是否需要打开。它们也可以用在热水壶中去检测水温。</p>
<p>提示：温度传感器的位置会显著地影响它们的功能。最理想的情况下，他们应该放置在远离大门和控制器的位置，距离天花板稍微往下。如果你注意到一些房间感觉比其它设置在同一温度时更热，这可能是跟传感器位置有关。当然，如果你已经注意到了这些问题，你可以改变温度设置，而不一定需要移动传感器位置。</p>
<h4 id="-">整合型传感器</h4>
<p>由于运动，光，温湿度传感器在家居自动化系统中使用非常普遍，一些制造商将它们打包成一个独立的单元称之为整合型传感器。购买3或4个元件整合在一起开源节省资金，并且可以减少贴在你天花板和墙壁的塑料盒数量。</p>
<h4 id="-">火灾报警传感器</h4>
<p>在家居系统中的火灾报警传感器有3个主要的类型：</p>
<ul>
<li>光学/光电：这是最常见的类型。它使用光束来探测，如果烟雾颗粒中断了光束则会触发报警。</li>
<li>电离：检测空气中的电离粒子，这类比光学更敏感。然而，这意味着它比光学传感器更容易产生误报警。许多现代系统使用光学和电离的组合。</li>
<li>热：检测到异常的温度</li>
</ul>
<p>提示：如果你在烹饪时触发了报警，并且一直持续，请不要断开它而让自己处于无保护状态。这类误报是由于使用了错误类型的警报器。很多人甚至不知道有各种不同类型的警报器，因而在厨房周围安装了错误类型的警报器。不过请记住，这是一个高风险区域，并且绝对不能没有探测器。最好是使用一个热探测器，这将不会被油炸或者烤面包时烟雾所触发，但仍然可以及时检测到潜在的火灾从而拯救你的生命。</p>
<h4 id="-">一氧化碳传感器</h4>
<p>火并不是你需要保护你家人免受伤害的唯一风险。在美国，每年有成百上千人由于错误地使用家用电器导致一氧化碳中毒死亡。</p>
<p>一氧化碳是一种无色，无味的气体，它可以杀人于无形。中毒症状包括头痛，头晕，恶心，所有这些都是容易由其他事物引起的，这意味着有些患者可能仅仅认为他们自己只是由于天气原因导致的不舒服，去趟一会儿，但永远醒不来了。</p>
<p>提示：保护你的家人最经济的方法是购买一个一氧化碳和火警混合的报警，但是如果这不是一个先进的家居自动化系统组成部分，请确保你记住了不同的报警声音，而不至于误认为是火警误报却实际上是一氧化碳报警。</p>
<h4 id="-">洪水和泄漏传感器</h4>
<p>洪水或泄漏传感器通常安装在浴室或者厨房水槽，或者在其它有高风险导致泄漏的地方。由于水的危害主要是针对你的财产，如果你及早发现你的水管泄漏，你可以节省很多麻烦和费用。对于质量好的洪水/泄漏探测器，可以检测出来很小的泄漏，如果连接到阀门，它们能够自动地关闭水源，防止带来损失。</p>
<h4 id="-">接近传感器</h4>
<p>在某些系统中，接近传感器可以用来替代开关。这将允许用户只需简单地将手轻轻拂在安装了传感器的墙上，而不需要实际按下去触发，例如，打开电灯。它们也可以广泛地被用在更先进的系统中,比如自动喂鸟器。</p>
<h4 id="-">接触式传感器</h4>
<p>接触传感器也被广泛使用，最常见的一种是防盗警报。传感器本身是一种开关，它在两个表面相接触时会发送一个电信号。它们可以被用于检测是否有门或窗开启或关闭。</p>
<p>家庭安全系统通常在窗框中使用接触式传感器，传感器激活后，如果窗户被打开，则会触发报警。还有很多其他应用，比如：</p>
<ul>
<li>如果有人打开窗户，自动关闭房间里面的暖气，节约能源并且使房间更容易凉快下来。</li>
<li>如果电动门系统安装了，你可以从远程检查门是打开还是关闭的。</li>
<li>当你打开门的时候点亮柜灯。</li>
</ul>
<h4 id="-">玻璃破裂传感器</h4>
<p>有两种不同的传感器，可以用来检测入侵者打碎玻璃进入你的房子。</p>
<p>第一种类型是安装在窗口本身，限制于它的实用性仅在于保护整个玻璃。这种又被称为“震荡传感器”，它由所贴合的玻璃破碎时产生的高频率震动触发。</p>
<p>第二种类型基本上是一个专门调试过用于辨别玻璃破碎声音的麦克风。这种更有用，因为单一的探测器甚至能够覆盖有很多窗户的大房间。</p>
<h4 id="-">麦克风</h4>
<p>在我看来，语言控制是建立一个家庭自动化系统最有趣的特性之一。虽然语音识别技术已经有一段时间了，通过语音命令控制你家用电器和电子设备还是令人激动。</p>
<p>很明显，如果你想要语音识别功能，你需要一个麦克风。所需的麦克风质量不需特别高，所以无需花一大笔钱在专业品质的产品上。</p>
<p>最近推出的一个有趣的系统是CastleOS,利用了微软Xbox的Kinnect系统，或者Windows去检测和翻译语音命令。由于Kinnect是一个高质量的系统，它非常可靠和灵活，但如果你想在家里的每个房间都使用，那将会很昂贵。</p>
<h4 id="-">车道探针</h4>
<p>将一个车道探针嵌入到你家的外面的车道，然后你就能用来探测车辆的到达和离开。这个信息可以被用在自动化系统中，比如，在你离开时打开车库门。它也可以被用做为警报系统的一个部分，在车辆到达你的车道时开始记录，并且过一段时间自动触发警报。</p>
<p><img src="http://ww4.sinaimg.cn/large/674a21d2gw1edp20mupb4j20eg05vt8q.jpg" alt="车道探针"></p>
<h2 id="-raspbmc-">树莓派和用于网络家庭娱乐的Raspbmc系统</h2>
<p>XBMC是一个优秀的开源软件系统，通过它你可以打造属于你自己的家庭影院电脑，媒体服务器，并通过自定义的机顶盒将你的普通电视变成智能电视。这是一个建立你自己的廉价网络家庭娱乐系统的好方案。</p>
<p>大部分人安装XBMC到个人电脑，但你也可以使用树莓派。树莓派的最创新的特性之一是它对高清晰度视频格式的支持，因而是此类项目的一个好选择。</p>
<p>Raspbmc是开源Linux系统Debian的一个免费分发版本，和树莓派使用同样的操作系统。它预装了为低功率PI板子优化过的XBMC。相比其他的DIY家庭影院、网络家庭娱乐系统软件，比如Myth TV，Raspbmc更易于安装和使用，即使你之前从未使用过Linux。当然，它也有着很多先进的特性和定制选项。</p>
<h2 id="privateeyepi-">PrivateEyePi 家庭监控</h2>
<p>PrivateEyePi提供免费的开源软件，你可以用于构建一系列的DIY智能家居项目，侧重于“家庭监控”。如果你对于使用Pi创建自有的家居安保系统感兴趣，那么这就是一个很好的开始。</p>
<p>除了免费的软件，PrivateEyePi有着手把手教程对于一系列项目。并且也有一个价格合理的商店提供，便于你去购买可能需要的一些额外组件和设备。</p>
<p><img src="http://ww1.sinaimg.cn/large/674a21d2gw1edoocmcnftj20eg0b5gm2.jpg" alt="PrivateEyePi"></p>
<h2 id="homeaidpi">HomeAidPi</h2>
<p>HomeAidPi和Razberry遵循一个类似的概念，除了它支持更大范围的系统并且更贵一点。HomeAidPi本身是免费的软件，它将你的Pi转变成一个智能家居控制器，可以广泛用于流行的协议比如，Insteon，X-10和Zigbee等。</p>
<p><img src="http://ww1.sinaimg.cn/large/674a21d2gw1edoodfcgyaj20eg09xjse.jpg" alt="HomeAidPi"></p>
<h2 id="-">其他资源 - 一些教程和开源软件</h2>
<h4 id="pihome-">PiHome 树莓派家庭自动化开源项目</h4>
<p>这是一个适用于树莓派的高质量开源DIY家居自动化解决方案，可能并不适合初学者。
<a href="http://pihome.harkemedia.de/" target="_blank">http://pihome.harkemedia.de/</a></p>
<h4 id="rasplogic">RaspLogic</h4>
<p>Rasplogic是一个软件，它提供简单的，用户友好的并且廉价的方法，去控制房间中的一切东西。楼宇自动化系统是我们的主要关注点
<a href="http://www.rasplogic.com/the-project/" target="_blank">http://www.rasplogic.com/the-project/</a></p>
<h4 id="raspberry-pi-gpio-">Raspberry Pi GPIO 家庭自动化</h4>
<p><a href="http://www.instructables.com/id/Raspberry-Pi-GPIO-home-automation/" target="_blank">http://www.instructables.com/id/Raspberry-Pi-GPIO-home-automation/</a></p>
<h4 id="-arudino-">如何使用树莓派和Arudino实现一个家居自动化系统</h4>
<p><a href="http://www.makeuseof.com/tag/how-to-build-home-automation-system-raspberry-pi-and-arduino/" target="_blank">http://www.makeuseof.com/tag/how-to-build-home-automation-system-raspberry-pi-and-arduino/</a></p>
]]></content>
    <summary type="html"><![CDATA[<h2 id="-">原文</h2>
<ul>
<li><a href="http://electronician.hubpages.com/hub/DIY-Home-Automation-with-Raspberry-Pi" target="_blank">http://electronician.hubpages.com/hub/DIY-Home-Automation-with-Raspberry-Pi</a></li>
<li><a href="http://electronician.hubpages.com/hub/Home-Automation-Sensors" target="_blank">http://electronician.hubpages.com/hub/Home-Automation-Sensors</a>
（有少量删减与整合）</li>
</ul>
<h2 id="-">通过树莓派使你的家庭智能化</h2>
<p>树莓派是一个廉价的电路板，又称微控制器。它其实是一个在单片机上的小型电脑，最初设计出来是出于兴趣以及帮助学生学习电子和编程。和常见的电脑比较，它非常节能，这意味着它可以一直处于打开状态而不会耗费多少电能，并且它能够很容易地被连接到各种外设和电路板上。</p>
]]></summary>
    
      <category term="译文" scheme="http://yoursite.com/tags/%E8%AF%91%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[树莓派适用的传感器(一)]]></title>
    <link href="http://yoursite.com/2014/02/12/sensors-for-raspberry-pi-1/"/>
    <id>http://yoursite.com/2014/02/12/sensors-for-raspberry-pi-1/</id>
    <published>2014-02-12T05:47:19.000Z</published>
    <updated>2014-02-14T07:52:53.000Z</updated>
    <content type="html"><![CDATA[<h2 id="dht11-">DHT11 温湿度传感器</h2>
<h3 id="-">技术参数</h3>
<ul>
<li>供电电压:3.3-5.5V DC</li>
<li>输出:单总线数字信号</li>
<li>测量范围:湿度20-90%RH ，温度0-50℃</li>
<li>测量精度:湿度+-5%RH， 温度+-2℃</li>
</ul>
<a id="more"></a>

<h3 id="-">接线图例</h3>
<p><img src="http://ww4.sinaimg.cn/large/674a21d2gw1edgk7ctgq7j20fd06laa6.jpg" alt="接线图"></p>
<h2 id="hc-sr04-">HC-SR04 超声波测距模块</h2>
<h3 id="-">技术参数</h3>
<ul>
<li>供电电压：5V DC</li>
<li>静态电流：小于2mA</li>
<li>感应角度：不大于15°</li>
<li>探测距离：2cm-450cm</li>
<li>精度：0.2cm</li>
</ul>
<h3 id="-">接线图例</h3>
<p><img src="http://ww1.sinaimg.cn/large/674a21d2gw1edgwyknjqcj20eq0a9wew.jpg" alt="接线图"></p>
<h3 id="-">参考资料</h3>
<p><a href="http://www.raspberrypi-spy.co.uk/2012/12/ultrasonic-distance-measurement-using-python-part-1/" target="_blank">http://www.raspberrypi-spy.co.uk/2012/12/ultrasonic-distance-measurement-using-python-part-1/</a></p>
<h2 id="hc-sr501-">HC-SR501 人体红外传感器</h2>
<h3 id="-">技术参数</h3>
<ul>
<li>供电电压：5 - 20V DC</li>
<li>静态功耗：65微安</li>
<li>电平输出：高3.3V 低0V</li>
<li>延时时间：0.3-18秒（可调）</li>
<li>触发方式：L不可重复 H可重复 默认H</li>
<li>感应范围：小于120°锥角 7米内</li>
<li>工作温度：-15 - +70 ℃</li>
</ul>
<h3 id="-">接线图例</h3>
<p><img src="http://ww1.sinaimg.cn/large/674a21d2gw1ediygtzvvhj20fa06ywen.jpg" alt="接线图"></p>
<h3 id="-">参考资料</h3>
<p><a href="http://www.raspberrypi-spy.co.uk/2013/01/cheap-pir-sensors-and-the-raspberry-pi-part-1/" target="_blank">http://www.raspberrypi-spy.co.uk/2013/01/cheap-pir-sensors-and-the-raspberry-pi-part-1/</a></p>
]]></content>
    <summary type="html"><![CDATA[<h2 id="dht11-">DHT11 温湿度传感器</h2>
<h3 id="-">技术参数</h3>
<ul>
<li>供电电压:3.3-5.5V DC</li>
<li>输出:单总线数字信号</li>
<li>测量范围:湿度20-90%RH ，温度0-50℃</li>
<li>测量精度:湿度+-5%RH， 温度+-2℃</li>
</ul>
]]></summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[关于树莓派GPIO接口 一些资料整理]]></title>
    <link href="http://yoursite.com/2014/02/11/raspberry-pi-gpio/"/>
    <id>http://yoursite.com/2014/02/11/raspberry-pi-gpio/</id>
    <published>2014-02-11T12:04:39.000Z</published>
    <updated>2014-02-11T15:18:00.000Z</updated>
    <content type="html"><![CDATA[<h2 id="-">前言</h2>
<p>去年12月份入手了树莓派，由于同时在实习，一直没太多时间去把玩她，趁着要做毕业设计，加上寒假在家，就着手开始折腾。</p>
<p>折腾的同时记录一些资料于此，方便之后使用。</p>
<a id="more"></a>

<h2 id="-gpio">什么是GPIO</h2>
<p>作为一台廉价Linux电脑，树莓派与我们日常所见的PC最明显的不同，在于她提供了一组GPIO
（General Purpose Input &amp; Output, 通用型输入输出）接口。</p>
<p><img src="http://ww3.sinaimg.cn/large/674a21d2gw1edfrpddve1j20720g53zr.jpg" alt="GPIO接口引脚图"></p>
<p>上图可见部分引脚有两个标记，R1表示第一版树莓派(256MB内存版本)，R2表示第二版（512MB内存）
对于树莓派版本的判别，也可以通过在终端中输入以下命令查看CPU信息</p>
<p><code>cat /proc/cpuinfo</code></p>
<p>其中的Revision信息为0002或0003，则为第一版，更大的版本号或者包含字母则为第二版</p>
<p>GPIO端口提供了7个通用的引脚和pin7 (GPIO4),默认提供时钟信号，但也可以做一般用途。总共8个引脚可以在两个状态之间切换：正电压3.3V高电平，以及接地或者0V的低电平，相当于 1和0的二进制逻辑，并可以用于打开或者关闭其他组件。</p>
<h2 id="-gpio">如何操作GPIO</h2>
<h3 id="-gpio-">官方GPIO模块</h3>
<p>树莓派默认的Raspbian系统新版内置了该GPIO模块，对于早期版本则需要手动安装</p>
<p>安装</p>
<p><code>sudo apt-get install python-rpi.gpio</code></p>
<p>开源地址 <a href="http://sourceforge.net/projects/raspberry-gpio-python/" target="_blank">http://sourceforge.net/projects/raspberry-gpio-python/</a></p>
<h3 id="wiringpi">WiringPi</h3>
<p>WiringPi是一个针对树莓派平台封装好的驱动库，有C,Python,PHP,Ruby,Perl等多种语言的实现。</p>
<p>Python下安装可以直接使用pip安装</p>
<p><code>sudo pip install wiringpi2</code></p>
<p>开源地址 <a href="https://github.com/WiringPi/WiringPi-Python" target="_blank">https://github.com/WiringPi/WiringPi-Python</a></p>
<p>使用WiringPi库封装后的引脚映射关系图</p>
<p><img src="http://ww4.sinaimg.cn/large/674a21d2gw1edfq5oh4kkj20iy0hhta6.jpg" alt="映射关系图"></p>
<h2 id="-">参考资料</h2>
<p> 树莓派学习笔记 <a href="http://blog.csdn.net/xukai871105/article/category/1436049" target="_blank">http://blog.csdn.net/xukai871105/article/category/1436049</a></p>
<p>《Getting Started with Raspberry Pi》Matt Richardson &amp; Shawn Wallace</p>
<p>《Raspberry Pi 用户指南》 Eben Upton &amp; Gareth Halfacree</p>
]]></content>
    <summary type="html"><![CDATA[<h2 id="-">前言</h2>
<p>去年12月份入手了树莓派，由于同时在实习，一直没太多时间去把玩她，趁着要做毕业设计，加上寒假在家，就着手开始折腾。</p>
<p>折腾的同时记录一些资料于此，方便之后使用。</p>
]]></summary>
    
  </entry>
  
</feed>
